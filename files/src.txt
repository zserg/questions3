Q1. Describe the Collections Type Hierarchy. What Are the Main Interfaces, and What Are the Differences Between Them?

The Iterable interface represents any collection that can be iterated using the for-each loop. The Collection interface inherits from Iterable and adds generic methods for checking if an element is in a collection, adding and removing elements from the collection, determining its size etc.

The List, Set, and Queue interfaces inherit from the Collection interface.

List is an ordered collection, and its elements can be accessed by their index in the list.

Set is an unordered collection with distinct elements, similar to the mathematical notion of a set.

Queue is a collection with additional methods for adding, removing and examining elements, useful for holding elements prior to processing.

Map interface is also a part of the collection framework, yet it does not extend Collection. This is by design, to stress the difference between collections and mappings which are hard to gather under a common abstraction. The Map interface represents a key-value data structure with unique keys and no more than one value for each key.

 
Q2. Describe Various Implementations of the Map Interface and Their Use Case Differences.

One of the most often used implementations of the Map interface is the HashMap. It is a typical hash map data structure that allows accessing elements in constant time, or O(1), but does not preserve order and is not thread-safe.

To preserve insertion order of elements, you can use the LinkedHashMap class which extends the HashMap and additionally ties the elements into a linked list, with foreseeable overhead.

The TreeMap class stores its elements in a red-black tree structure, which allows accessing elements in logarithmic time, or O(log(n)). It is slower than the HashMap for most cases, but it allows keeping the elements in order according to some Comparator.

The ConcurrentHashMap is a thread-safe implementation of a hash map. It provides full concurrency of retrievals (as the get operation does not entail locking) and high expected concurrency of updates.

The Hashtable class has been in Java since version 1.0. It is not deprecated but is mostly considered obsolete. It is a thread-safe hash map, but unlike ConcurrentHashMap, all its methods are simply synchronized, which means that all operations on this map block, even retrieval of independent values.

 
Q3. Explain the Difference Between Linkedlist and Arraylist.

ArrayList is an implementation of the List interface that is based on an array. ArrayList internally handles resizing of this array when the elements are added or removed. You can access its elements in constant time by their index in the array. However, inserting or removing an element infers shifting all consequent elements which may be slow if the array is huge and the inserted or removed element is close to the beginning of the list.

LinkedList is a doubly-linked list: single elements are put into Node objects that have references to previous and next Node. This implementation may appear more efficient than ArrayList if you have lots of insertions or deletions in different parts of the list, especially if the list is large.

In most cases, however, ArrayList outperforms LinkedList. Even elements shifting in ArrayList, while being an O(n) operation, is implemented as a very fast System.arraycopy() call. It can even appear faster than the LinkedList‘s O(1) insertion which requires instantiating a Node object and updating multiple references under the hood. LinkedList also can have a large memory overhead due to a creation of multiple small Node objects.

 
Q4. What Is the Difference Between Hashset and Treeset?

Both HashSet and TreeSet classes implement the Set interface and represent sets of distinct elements. Additionally, TreeSet implements the NavigableSet interface. This interface defines methods that take advantage of the ordering of elements.

HashSet is internally based on a HashMap, and TreeSet is backed by a TreeMap instance, which defines their properties: HashSet does not keep elements in any particular order. Iteration over the elements in a HashSet produces them in a shuffled order. TreeSet, on the other hand, produces elements in order according to some predefined Comparator.

 
Q5. How Is Hashmap Implemented in Java? How Does Its Implementation Use Hashcode and Equals Methods of Objects? What Is the Time Complexity of Putting and Getting an Element from Such Structure?

The HashMap class represents a typical hash map data structure with certain design choices.

The HashMap is backed by a resizable array that has a size of power-of-two. When the element is added to a HashMap, first its hashCode is calculated (an int value). Then a certain number of lower bits of this value are used as an array index. This index directly points to the cell of the array (called a bucket) where this key-value pair should be placed. Accessing an element by its index in an array is a very fast O(1) operation, which is the main feature of a hash map structure.

A hashCode is not unique, however, and even for different hashCodes, we may receive the same array position. This is called a collision. There is more than one way of resolving collisions in the hash map data structures. In Java's HashMap, each bucket actually refers not to a single object, but to a red-black tree of all objects that landed in this bucket (prior to Java 8, this was a linked list).

So when the HashMap has determined the bucket for a key, it has to traverse this tree to put the key-value pair in its place. If a pair with such key already exists in the bucket, it is replaced with a new one.

To retrieve the object by its key, the HashMap again has to calculate the hashCode for the key, find the corresponding bucket, traverse the tree, call equals on keys in the tree and find the matching one.

HashMap has O(1) complexity, or constant-time complexity, of putting and getting the elements. Of course, lots of collisions could degrade the performance to O(log(n)) time complexity in the worst case, when all elements land in a single bucket. This is usually solved by providing a good hash function with a uniform distribution.

When the HashMap internal array is filled (more on that in the next question), it is automatically resized to be twice as large. This operation infers rehashing (rebuilding of internal data structures), which is costly, so you should plan the size of your HashMap beforehand.

 
Q6. What Is the Purpose of the Initial Capacity and Load Factor Parameters of a Hashmap? What Are Their Default Values?

The initialCapacity argument of the HashMap constructor affects the size of the internal data structure of the HashMap, but reasoning about the actual size of a map is a bit tricky. The HashMap‘s internal data structure is an array with the power-of-two size. So the initialCapacity argument value is increased to the next power-of-two (for instance, if you set it to 10, the actual size of the internal array will be 16).

The load factor of a HashMap is the ratio of the element count divided by the bucket count (i.e. internal array size). For instance, if a 16-bucket HashMap contains 12 elements, its load factor is 12/16 = 0.75. A high load factor means a lot of collisions, which in turn means that the map should be resized to the next power of two. So the loadFactor argument is a maximum value of the load factor of a map. When the map achieves this load factor, it resizes its internal array to the next power-of-two value.

The initialCapacity is 16 by default, and the loadFactor is 0.75 by default, so you could put 12 elements in a HashMap that was instantiated with the default constructor, and it would not resize. The same goes for the HashSet, which is backed by a HashMap instance internally.

Consequently, it is not trivial to come up with initialCapacity that satisfies your needs. This is why the Guava library has Maps.newHashMapWithExpectedSize() and Sets.newHashSetWithExpectedSize() methods that allow you to build a HashMap or a HashSet that can hold the expected number of elements without resizing.
Q7. Describe Special Collections for Enums. What Are the Benefits of Their Implementation Compared to Regular Collections?

EnumSet and EnumMap are special implementations of Set and Map interfaces correspondingly. You should always use these implementations when you're dealing with enums because they are very efficient.

An EnumSet is just a bit vector with “ones” in the positions corresponding to ordinal values of enums present in the set. To check if an enum value is in the set, the implementation simply has to check if the corresponding bit in the vector is a “one”, which is a very easy operation. Similarly, an EnumMap is an array accessed with enum's ordinal value as an index. In the case of EnumMap, there is no need to calculate hash codes or resolve collisions.

 
Q8. What Is the Difference Between Fail-Fast and Fail-Safe Iterators?

Iterators for different collections are either fail-fast or fail-safe, depending on how they react to concurrent modifications. The concurrent modification is not only a modification of collection from another thread but also modification from the same thread but using another iterator or modifying the collection directly.

Fail-fast iterators (those returned by HashMap, ArrayList, and other non-thread-safe collections) iterate over the collection's internal data structure, and they throw ConcurrentModificationException as soon as they detect a concurrent modification.

Fail-safe iterators (returned by thread-safe collections such as ConcurrentHashMap, CopyOnWriteArrayList) create a copy of the structure they iterate upon. They guarantee safety from concurrent modifications. Their drawbacks include excessive memory consumption and iteration over possibly out-of-date data in case the collection was modified.

 
Q9. How Can You Use Comparable and Comparator Interfaces to Sort Collections?

The Comparable interface is an interface for objects that can be compared according to some order. Its single method is compareTo, which operates on two values: the object itself and the argument object of the same type. For instance, Integer, Long, and other numeric types implement this interface. String also implements this interface, and its compareTo method compares strings in lexicographical order.

The Comparable interface allows to sort lists of corresponding objects with the Collections.sort() method and uphold the iteration order in collections that implement SortedSet and SortedMap. If your objects can be sorted using some logic, they should implement the Comparable interface.

The Comparable interface usually is implemented using natural ordering of the elements. For instance, all Integer numbers are ordered from lesser to greater values. But sometimes you may want to implement another kind of ordering, for instance, to sort the numbers in descending order. The Comparator interface can help here.

The class of the objects you want to sort does not need to implement this interface. You simply create an implementing class and define the compare method which receives two objects and decides how to order them. You may then use the instance of this class to override the natural ordering of the Collections.sort() method or SortedSet and SortedMap instances.

As the Comparator interface is a functional interface, you may replace it with a lambda expression, as in the following example. It shows ordering a list using a natural ordering (Integer‘s Comparable interface) and using a custom iterator (Comparator<Integer> interface).

List<Integer> list1 = Arrays.asList(5, 2, 3, 4, 1);
Collections.sort(list1);
assertEquals(new Integer(1), list1.get(0));

List<Integer> list1 = Arrays.asList(5, 2, 3, 4, 1);
Collections.sort(list1, (a, b) -> b - a);
assertEquals(new Integer(5), list1.get(0));

Next »
Java Type System Interview Questions
Get started with Spring 5 and Spring Boot 2, through the Learn Spring course:
>> CHECK OUT THE COURSE
Learning to build your API
with Spring?
Download the E-book
Comments are closed on this article!
opt-in
Building a REST API with Spring 5?
Download the E-book
The Baeldung logo
Courses

    All Courses
    All Bulk Courses
    The Courses Platform

Series

    Java “Back to Basics” Tutorial
    Jackson JSON Tutorial
    HttpClient 4 Tutorial
    REST with Spring Tutorial
    Spring Persistence Tutorial
    Security with Spring
    Spring Reactive Tutorials

About

    About Baeldung
    The Full Archive
    Write for Baeldung
    Editors
    Jobs
    Our Partners
    Advertise on Baeldung

    Terms of Service Privacy Policy Company Info Contact 

Tell about yourself
Your project: adm
Your project: cameroon
Your project: rwanda
Your project: tms



The Baeldung Logo
Start Here
Courses ▼
Guides ▼
About ▼

Java Type System Interview Questions

Last modified: July 9, 2020
by baeldung

    Java+ 

    Interview 

Your logs should hold the key to the problem, right? It’s why we build intricate logging systems, create best practices on how and what to log in our teams and streamline as much of the adding, consuming, and analyzing our production logs as possible. But, the reality is that you can’t log all the things. It can’t be done. Not without producing literally unconscionable amounts of unnecessary log data.

There’s another option: Lightrun.
With Lightrun, you can add logs directly into production in a secure (i.e. without opening debug ports), read-only (i.e. without side effects), and real-time (i.e. no redeploying, restarting, or even stopping the running applications) way.
This article is part of a series:
1. Introduction

Java Type System is a topic often brought up on technical interviews for Java developers. This article reviews some important questions that are asked most often and may be tricky to get right.
2. Questions
Q1. Describe the Place of the Object Class in the Type Hierarchy. Which Types Inherit from Object, and Which Don’t? Do Arrays Inherit from Object? Can a Lambda Expression Be Assigned to an Object Variable?

The java.lang.Object is at the top of the class hierarchy in Java. All classes inherit from it, either explicitly, implicitly (when the extends keyword is omitted from the class definition) or transitively via the chain of inheritance.

However, there are eight primitive types that do not inherit from Object, namely boolean, byte, short, char, int, float, long and double.

According to the Java Language Specification, arrays are objects too. They can be assigned to an Object reference, and all Object methods may be called on them.

Lambda expressions can't be assigned directly to an Object variable because Object is not a functional interface. But you can assign a lambda to a functional interface variable and then assign it to an Object variable(or simply assign it to an Object variable by casting it to a functional interface at the same time).

 
Q2. Explain the Difference Between Primitive and Reference Types.

Reference types inherit from the top java.lang.Object class and are themselves inheritable (except final classes). Primitive types do not inherit and cannot be subclassed.

Primitively typed argument values are always passed via the stack, which means they are passed by value, not by reference. This has the following implication: changes made to a primitive argument value inside the method do not propagate to the actual argument value.

Primitive types are usually stored using the underlying hardware value types.

For instance, to store an int value, a 32-bit memory cell can be used. Reference types introduce the overhead of object header which is present in every instance of a reference type.

The size of an object header can be quite significant in relation to a simple numeric value size. This is why the primitive types were introduced in the first place — to save space on object overhead. The downside is that not everything in Java technically is an object — primitive values do not inherit from Object class.

 
Q3. Describe the Different Primitive Types and the Amount of Memory They Occupy.

Java has 8 primitive types:

    boolean — logical true/false value. The size of boolean is not defined by the JVM specification and can vary in different implementations.
    byte — signed 8-bit value,
    short — signed 16-bit value,
    char — unsigned 16-bit value,
    int — signed 32-bit value,
    long — signed 64-bit value,
    float — 32-bit single precision floating point value corresponding to the IEEE 754 standard,
    double — 64-bit double precision floating point value corresponding to the IEEE 754 standard.

 
Q4. What Is the Difference Between an Abstract Class and an Interface? What Are the Use Cases of One and the Other?

An abstract class is a class with the abstract modifier in its definition. It can't be instantiated, but it can be subclassed. The interface is a type described with interface keyword. It also cannot be instantiated, but it can be implemented.

The main difference between an abstract class and an interface is that a class can implement multiple interfaces, but extend only one abstract class.

An abstract class is usually used as a base type in some class hierarchy, and it signifies the main intention of all classes that inherit from it.

An abstract class could also implement some basic methods needed in all subclasses. For instance, most map collections in JDK inherit from the AbstractMap class which implements many methods used by subclasses (such as the equals method).

An interface specifies some contract that the class agrees to. An implemented interface may signify not only the main intention of the class but also some additional contracts.

For instance, if a class implements the Comparable interface, this means that instances of this class may be compared, whatever the main purpose of this class is.

 
Q5. What Are the Restrictions on the Members (Fields and Methods) of an Interface Type?

An interface can declare fields, but they are implicitly declared as public, static and final, even if you don't specify those modifiers. Consequently, you can't explicitly define an interface field as private. In essence, an interface may only have constant fields, not instance fields.

All methods of an interface are also implicitly public. They also can be either (implicitly) abstract, or default.

 
Q6. What Is the Difference Between an Inner Class and a Static Nested Class?

Simply put – a nested class is basically a class defined inside another class.

Nested classes fall into two categories with very different properties. An inner class is a class that can't be instantiated without instantiating the enclosing class first, i.e. any instance of an inner class is implicitly bound to some instance of the enclosing class.

Here's an example of an inner class – you can see that it can access the reference to the outer class instance in the form of OuterClass1.this construct:

public class OuterClass1 {

    public class InnerClass {

        public OuterClass1 getOuterInstance() {
            return OuterClass1.this;
        }

    }

}

To instantiate such inner class, you need to have an instance of an outer class:

OuterClass1 outerClass1 = new OuterClass1();
OuterClass1.InnerClass innerClass = outerClass1.new InnerClass();

Static nested class is quite different. Syntactically it is just a nested class with the static modifier in its definition.

In practice, it means that this class may be instantiated as any other class, without binding it to any instance of the enclosing class:

public class OuterClass2 {

    public static class StaticNestedClass {
    }

}

To instantiate such class, you don't need an instance of outer class:

OuterClass2.StaticNestedClass staticNestedClass = new OuterClass2.StaticNestedClass();

 
Q7. Does Java Have Multiple Inheritance?

Java does not support the multiple inheritance for classes, which means that a class can only inherit from a single superclass.

But you can implement multiple interfaces with a single class, and some of the methods of those interfaces may be defined as default and have an implementation. This allows you to have a safer way of mixing different functionality in a single class.

 
Q8. What Are the Wrapper Classes? What Is Autoboxing?

For each of the eight primitive types in Java, there is a wrapper class that can be used to wrap a primitive value and use it like an object. Those classes are, correspondingly, Boolean, Byte, Short, Character, Integer, Float, Long, and Double. These wrappers can be useful, for instance, when you need to put a primitive value into a generic collection, which only accepts reference objects.

List<Integer> list = new ArrayList<>();
list.add(new Integer(5));

To save the trouble of manually converting primitives back and forth, an automatic conversion known as autoboxing/auto unboxing is provided by the Java compiler.

List<Integer> list = new ArrayList<>();
list.add(5);
int value = list.get(0);

 
Q9. Describe the Difference Between equals() and ==

The == operator allows you to compare two objects for “sameness” (i.e. that both variables refer to the same object in memory). It is important to remember that the new keyword always creates a new object which will not pass the == equality with any other object, even if they seem to have the same value:

String string1 = new String("Hello");
String string2 = new String("Hello");

assertFalse(string1 == string2);

Also, the == operator allows to compare primitive values:

int i1 = 5;
int i2 = 5;

assertTrue(i1 == i2);

The equals() method is defined in the java.lang.Object class and is, therefore, available for any reference type. By default, it simply checks that the object is the same via the == operator. But it is usually overridden in subclasses to provide the specific semantics of comparison for a class.

For instance, for String class this method checks if the strings contain the same characters:

String string1 = new String("Hello");
String string2 = new String("Hello");

assertTrue(string1.equals(string2));

 
Q10. Suppose You Have a Variable That References an Instance of a Class Type. How Do You Check That an Object Is an Instance of This Class?

You cannot use instanceof keyword in this case because it only works if you provide the actual class name as a literal.

Thankfully, the Class class has a method isInstance that allows checking if an object is an instance of this class:

Class<?> integerClass = new Integer(5).getClass();
assertTrue(integerClass.isInstance(new Integer(4)));

 
Q11. What Is an Anonymous Class? Describe Its Use Case.

Anonymous class is a one-shot class that is defined in the same place where its instance is needed. This class is defined and instantiated in the same place, thus it does not need a name.

Before Java 8, you would often use an anonymous class to define the implementation of a single method interface, like Runnable. In Java 8, lambdas are used instead of single abstract method interfaces. But anonymous classes still have use cases, for example, when you need an instance of an interface with multiple methods or an instance of a class with some added features.

Here's how you could create and populate a map:

Map<String, Integer> ages = new HashMap<String, Integer>(){{
    put("David", 30);
    put("John", 25);
    put("Mary", 29);
    put("Sophie", 22);
}};

Next »
Java Concurrency Interview Questions (+ Answers)
« Previous
Java Collections Interview Questions
Get started with Spring 5 and Spring Boot 2, through the Learn Spring course:
>> CHECK OUT THE COURSE
Learning to build your API
with Spring?
Download the E-book
Comments are closed on this article!
opt-in
Building a REST API with Spring 5?
Download the E-book
The Baeldung logo
Courses

    All Courses
    All Bulk Courses
    The Courses Platform

Series

    Java “Back to Basics” Tutorial
    Jackson JSON Tutorial
    HttpClient 4 Tutorial
    REST with Spring Tutorial
    Spring Persistence Tutorial
    Security with Spring
    Spring Reactive Tutorials

About

    About Baeldung
    The Full Archive
    Write for Baeldung
    Editors
    Jobs
    Our Partners
    Advertise on Baeldung

    Terms of Service Privacy Policy Company Info Contact 




The Baeldung Logo
Start Here
Courses ▼
Guides ▼
About ▼

Java Concurrency Interview Questions (+ Answers)

Last modified: December 22, 2021
by baeldung

    Java Concurrency 

    Interview 

Get started with Spring 5 and Spring Boot 2, through the Learn Spring course:
>> CHECK OUT THE COURSE
This article is part of a series:
1. Introduction

Concurrency in Java is one of the most complex and advanced topics brought up during technical interviews. This article provides answers to some of the interview questions on the topic that you may encounter.
Q1. What Is the Difference Between a Process and a Thread?

Both processes and threads are units of concurrency, but they have a fundamental difference: processes do not share a common memory, while threads do.

From the operating system's point of view, a process is an independent piece of software that runs in its own virtual memory space. Any multitasking operating system (which means almost any modern operating system) has to separate processes in memory so that one failing process wouldn't drag all other processes down by scrambling common memory.

The processes are thus usually isolated, and they cooperate by the means of inter-process communication which is defined by the operating system as a kind of intermediate API.

On the contrary, a thread is a part of an application that shares a common memory with other threads of the same application. Using common memory allows to shave off lots of overhead, design the threads to cooperate and exchange data between them much faster.
Q2. How Can You Create a Thread Instance and Run It?

To create an instance of a thread, you have two options. First, pass a Runnable instance to its constructor and call start(). Runnable is a functional interface, so it can be passed as a lambda expression:

Thread thread1 = new Thread(() ->
  System.out.println("Hello World from Runnable!"));
thread1.start();

Thread also implements Runnable, so another way of starting a thread is to create an anonymous subclass, override its run() method, and then call start():

Thread thread2 = new Thread() {
    @Override
    public void run() {
        System.out.println("Hello World from subclass!");
    }
};
thread2.start();

Q3. Describe the Different States of a Thread and When Do the State Transitions Occur.

The state of a Thread can be checked using the Thread.getState() method. Different states of a Thread are described in the Thread.State enum. They are:

    NEW — a new Thread instance that was not yet started via Thread.start()
    RUNNABLE — a running thread. It is called runnable because at any given time it could be either running or waiting for the next quantum of time from the thread scheduler. A NEW thread enters the RUNNABLE state when you call Thread.start() on it
    BLOCKED — a running thread becomes blocked if it needs to enter a synchronized section but cannot do that due to another thread holding the monitor of this section
    WAITING — a thread enters this state if it waits for another thread to perform a particular action. For instance, a thread enters this state upon calling the Object.wait() method on a monitor it holds, or the Thread.join() method on another thread
    TIMED_WAITING — same as the above, but a thread enters this state after calling timed versions of Thread.sleep(), Object.wait(), Thread.join() and some other methods
    TERMINATED — a thread has completed the execution of its Runnable.run() method and terminated

Q4. What Is the Difference Between the Runnable and Callable Interfaces? How Are They Used?

The Runnable interface has a single run method. It represents a unit of computation that has to be run in a separate thread. The Runnable interface does not allow this method to return value or to throw unchecked exceptions.

The Callable interface has a single call method and represents a task that has a value. That's why the call method returns a value. It can also throw exceptions. Callable is generally used in ExecutorService instances to start an asynchronous task and then call the returned Future instance to get its value.
Q5. What Is a Daemon Thread, What Are Its Use Cases? How Can You Create a Daemon Thread?

A daemon thread is a thread that does not prevent JVM from exiting. When all non-daemon threads are terminated, the JVM simply abandons all remaining daemon threads. Daemon threads are usually used to carry out some supportive or service tasks for other threads, but you should take into account that they may be abandoned at any time.

To start a thread as a daemon, you should use the setDaemon() method before calling start():

Thread daemon = new Thread(()
  -> System.out.println("Hello from daemon!"));
daemon.setDaemon(true);
daemon.start();

Curiously, if you run this as a part of the main() method, the message might not get printed. This could happen if the main() thread would terminate before the daemon would get to the point of printing the message. You generally should not do any I/O in daemon threads, as they won't even be able to execute their finally blocks and close the resources if abandoned.
Q6. What Is the Thread’s Interrupt Flag? How Can You Set and Check It? How Does It Relate to the Interruptedexception?

The interrupt flag, or interrupt status, is an internal Thread flag that is set when the thread is interrupted. To set it, simply call thread.interrupt() on the thread object.

If a thread is currently inside one of the methods that throw InterruptedException (wait, join, sleep etc.), then this method immediately throws InterruptedException. The thread is free to process this exception according to its own logic.

If a thread is not inside such method and thread.interrupt() is called, nothing special happens. It is thread's responsibility to periodically check the interrupt status using static Thread.interrupted() or instance isInterrupted() method. The difference between these methods is that the static Thread.interrupted() clears the interrupt flag, while isInterrupted() does not.
Q7. What Are Executor and Executorservice? What Are the Differences Between These Interfaces?

Executor and ExecutorService are two related interfaces of java.util.concurrent framework. Executor is a very simple interface with a single execute method accepting Runnable instances for execution. In most cases, this is the interface that your task-executing code should depend on.

ExecutorService extends the Executor interface with multiple methods for handling and checking the lifecycle of a concurrent task execution service (termination of tasks in case of shutdown) and methods for more complex asynchronous task handling including Futures.

For more info on using Executor and ExecutorService, see the article A Guide to Java ExecutorService.
Q8. What Are the Available Implementations of Executorservice in the Standard Library?

The ExecutorService interface has three standard implementations:

    ThreadPoolExecutor — for executing tasks using a pool of threads. Once a thread is finished executing the task, it goes back into the pool. If all threads in the pool are busy, then the task has to wait for its turn.
    ScheduledThreadPoolExecutor allows to schedule task execution instead of running it immediately when a thread is available. It can also schedule tasks with fixed rate or fixed delay.
    ForkJoinPool is a special ExecutorService for dealing with recursive algorithms tasks. If you use a regular ThreadPoolExecutor for a recursive algorithm, you will quickly find all your threads are busy waiting for the lower levels of recursion to finish. The ForkJoinPool implements the so-called work-stealing algorithm that allows it to use available threads more efficiently.

Q9. What Is Java Memory Model (Jmm)? Describe Its Purpose and Basic Ideas.

Java Memory Model is a part of Java language specification described in Chapter 17.4. It specifies how multiple threads access common memory in a concurrent Java application, and how data changes by one thread are made visible to other threads. While being quite short and concise, JMM may be hard to grasp without strong mathematical background.

The need for memory model arises from the fact that the way your Java code is accessing data is not how it actually happens on the lower levels. Memory writes and reads may be reordered or optimized by the Java compiler, JIT compiler, and even CPU, as long as the observable result of these reads and writes is the same.

This can lead to counter-intuitive results when your application is scaled to multiple threads because most of these optimizations take into account a single thread of execution (the cross-thread optimizers are still extremely hard to implement). Another huge problem is that the memory in modern systems is multilayered: multiple cores of a processor may keep some non-flushed data in their caches or read/write buffers, which also affects the state of the memory observed from other cores.

To make things worse, the existence of different memory access architectures would break the Java's promise of “write once, run everywhere”. Happily for the programmers, the JMM specifies some guarantees that you may rely upon when designing multithreaded applications. Sticking to these guarantees helps a programmer to write multithreaded code that is stable and portable between various architectures.

The main notions of JMM are:

    Actions, these are inter-thread actions that can be executed by one thread and detected by another thread, like reading or writing variables, locking/unlocking monitors and so on
    Synchronization actions, a certain subset of actions, like reading/writing a volatile variable, or locking/unlocking a monitor
    Program Order (PO), the observable total order of actions inside a single thread
    Synchronization Order (SO), the total order between all synchronization actions — it has to be consistent with Program Order, that is, if two synchronization actions come one before another in PO, they occur in the same order in SO
    synchronizes-with (SW) relation between certain synchronization actions, like unlocking of monitor and locking of the same monitor (in another or the same thread)
    Happens-before Order — combines PO with SW (this is called transitive closure in set theory) to create a partial ordering of all actions between threads. If one action happens-before another, then the results of the first action are observable by the second action (for instance, write of a variable in one thread and read in another)
    Happens-before consistency — a set of actions is HB-consistent if every read observes either the last write to that location in the happens-before order, or some other write via data race
    Execution — a certain set of ordered actions and consistency rules between them

For a given program, we can observe multiple different executions with various outcomes. But if a program is correctly synchronized, then all of its executions appear to be sequentially consistent, meaning you can reason about the multithreaded program as a set of actions occurring in some sequential order. This saves you the trouble of thinking about under-the-hood reorderings, optimizations or data caching.
Q10. What Is a Volatile Field and What Guarantees Does the Jmm Hold for Such Field?

A volatile field has special properties according to the Java Memory Model (see Q9). The reads and writes of a volatile variable are synchronization actions, meaning that they have a total ordering (all threads will observe a consistent order of these actions). A read of a volatile variable is guaranteed to observe the last write to this variable, according to this order.

If you have a field that is accessed from multiple threads, with at least one thread writing to it, then you should consider making it volatile, or else there is a little guarantee to what a certain thread would read from this field.

Another guarantee for volatile is atomicity of writing and reading 64-bit values (long and double). Without a volatile modifier, a read of such field could observe a value partly written by another thread.
Q11. Which of the Following Operations Are Atomic?

    writing to a non-volatile int;
    writing to a volatile int;
    writing to a non-volatile long;
    writing to a volatile long;
    incrementing a volatile long?

A write to an int (32-bit) variable is guaranteed to be atomic, whether it is volatile or not. A long (64-bit) variable could be written in two separate steps, for example, on 32-bit architectures, so by default, there is no atomicity guarantee. However, if you specify the volatile modifier, a long variable is guaranteed to be accessed atomically.

The increment operation is usually done in multiple steps (retrieving a value, changing it and writing back), so it is never guaranteed to be atomic, wether the variable is volatile or not. If you need to implement atomic increment of a value, you should use classes AtomicInteger, AtomicLong etc.
Q12. What Special Guarantees Does the Jmm Hold for Final Fields of a Class?

JVM basically guarantees that final fields of a class will be initialized before any thread gets hold of the object. Without this guarantee, a reference to an object may be published, i.e. become visible, to another thread before all the fields of this object are initialized, due to reorderings or other optimizations. This could cause racy access to these fields.

This is why, when creating an immutable object, you should always make all its fields final, even if they are not accessible via getter methods.
Q13. What Is the Meaning of a Synchronized Keyword in the Definition of a Method? of a Static Method? Before a Block?

The synchronized keyword before a block means that any thread entering this block has to acquire the monitor (the object in brackets). If the monitor is already acquired by another thread, the former thread will enter the BLOCKED state and wait until the monitor is released.

synchronized(object) {
    // ...
}

A synchronized instance method has the same semantics, but the instance itself acts as a monitor.

synchronized void instanceMethod() {
    // ...
}

For a static synchronized method, the monitor is the Class object representing the declaring class.

static synchronized void staticMethod() {
    // ...
}

Q14. If Two Threads Call a Synchronized Method on Different Object Instances Simultaneously, Could One of These Threads Block? What If the Method Is Static?

If the method is an instance method, then the instance acts as a monitor for the method. Two threads calling the method on different instances acquire different monitors, so none of them gets blocked.

If the method is static, then the monitor is the Class object. For both threads, the monitor is the same, so one of them will probably block and wait for another to exit the synchronized method.
Q15. What Is the Purpose of the Wait, Notify and Notifyall Methods of the Object Class?

A thread that owns the object's monitor (for instance, a thread that has entered a synchronized section guarded by the object) may call object.wait() to temporarily release the monitor and give other threads a chance to acquire the monitor. This may be done, for instance, to wait for a certain condition.

When another thread that acquired the monitor fulfills the condition, it may call object.notify() or object.notifyAll() and release the monitor. The notify method awakes a single thread in the waiting state, and the notifyAll method awakes all threads that wait for this monitor, and they all compete for re-acquiring the lock.

The following BlockingQueue implementation shows how multiple threads work together via the wait-notify pattern. If we put an element into an empty queue, all threads that were waiting in the take method wake up and try to receive the value. If we put an element into a full queue, the put method waits for the call to the get method. The get method removes an element and notifies the threads waiting in the put method that the queue has an empty place for a new item.

public class BlockingQueue<T> {

    private List<T> queue = new LinkedList<T>();

    private int limit = 10;

    public synchronized void put(T item) {
        while (queue.size() == limit) {
            try {
                wait();
            } catch (InterruptedException e) {}
        }
        if (queue.isEmpty()) {
            notifyAll();
        }
        queue.add(item);
    }

    public synchronized T take() throws InterruptedException {
        while (queue.isEmpty()) {
            try {
                wait();
            } catch (InterruptedException e) {}
        }
        if (queue.size() == limit) {
            notifyAll();
        }
        return queue.remove(0);
    }
    
}

Q16. Describe the Conditions of Deadlock, Livelock, and Starvation. Describe the Possible Causes of These Conditions.

Deadlock is a condition within a group of threads that cannot make progress because every thread in the group has to acquire some resource that is already acquired by another thread in the group. The most simple case is when two threads need to lock both of two resources to progress, the first resource is already locked by one thread, and the second by another. These threads will never acquire a lock to both resources and thus will never progress.

Livelock is a case of multiple threads reacting to conditions, or events, generated by themselves. An event occurs in one thread and has to be processed by another thread. During this processing, a new event occurs which has to be processed in the first thread, and so on. Such threads are alive and not blocked, but still, do not make any progress because they overwhelm each other with useless work.

Starvation is a case of a thread unable to acquire resource because other thread (or threads) occupy it for too long or have higher priority. A thread cannot make progress and thus is unable to fulfill useful work.
Q17. Describe the Purpose and Use-Cases of the Fork/Join Framework.

The fork/join framework allows parallelizing recursive algorithms. The main problem with parallelizing recursion using something like ThreadPoolExecutor is that you may quickly run out of threads because each recursive step would require its own thread, while the threads up the stack would be idle and waiting.

The fork/join framework entry point is the ForkJoinPool class which is an implementation of ExecutorService. It implements the work-stealing algorithm, where idle threads try to “steal” work from busy threads. This allows to spread the calculations between different threads and make progress while using fewer threads than it would require with a usual thread pool.

More information and code samples for the fork/join framework may be found in the article “Guide to the Fork/Join Framework in Java”.
Next »
Java Class Structure and Initialization Interview Questions
« Previous
Java Type System Interview Questions
Get started with Spring 5 and Spring Boot 2, through the Learn Spring course:
>> CHECK OUT THE COURSE
Learning to build your API
with Spring?
Download the E-book
Comments are closed on this article!
opt-in
Building a REST API with Spring 5?
Download the E-book
The Baeldung logo
Courses

    All Courses
    All Bulk Courses
    The Courses Platform

Series

    Java “Back to Basics” Tutorial
    Jackson JSON Tutorial
    HttpClient 4 Tutorial
    REST with Spring Tutorial
    Spring Persistence Tutorial
    Security with Spring
    Spring Reactive Tutorials

About

    About Baeldung
    The Full Archive
    Write for Baeldung
    Editors
    Jobs
    Our Partners
    Advertise on Baeldung

    Terms of Service Privacy Policy Company Info Contact 





The Baeldung Logo
Start Here
Courses ▼
Guides ▼
About ▼

Java Class Structure and Initialization Interview Questions

Last modified: August 3, 2021
by baeldung

    Java+ 

    Interview 

Your logs should hold the key to the problem, right? It’s why we build intricate logging systems, create best practices on how and what to log in our teams and streamline as much of the adding, consuming, and analyzing our production logs as possible. But, the reality is that you can’t log all the things. It can’t be done. Not without producing literally unconscionable amounts of unnecessary log data.

There’s another option: Lightrun.
With Lightrun, you can add logs directly into production in a secure (i.e. without opening debug ports), read-only (i.e. without side effects), and real-time (i.e. no redeploying, restarting, or even stopping the running applications) way.
This article is part of a series:
1. Introduction

Class structure and initialization are the basics that every Java programmer should be familiar with. This article provides answers to some of the interview questions on the topic that you may encounter.
Q1. Describe the Meaning of the Final Keyword When Applied to a Class, Method, Field or a Local Variable.

The final keyword has multiple different meanings when applied to different language constructs:

    A final class is a class that cannot be subclassed
    A final method is a method that cannot be overridden in subclasses
    A final field is a field that has to be initialized in the constructor or initializer block and cannot be modified after that
    A final variable is a variable that may be assigned (and has to be assigned) only once and is never modified after that

Q2. What Is a Default Method?

Prior to Java 8, interfaces could only have abstract methods, i.e. methods without a body. Starting with Java 8, interface methods can have a default implementation. If an implementing class does not override this method, then the default implementation is used. Such methods are suitably marked with a default keyword.

One of the prominent use cases of a default method is adding a method to an existing interface. If you don't mark such interface method as default, then all existing implementations of this interface will break. Adding a method with a default implementation ensures binary compatibility of legacy code with the new version of this interface.

A good example of this is the Iterator interface which allows a class to be a target of the for-each loop. This interface first appeared in Java 5, but in Java 8 it received two additional methods, forEach, and spliterator. They are defined as default methods with implementations and thus do not break backward compatibility:

public interface Iterable<T> {

    Iterator<T> iterator();

    default void forEach(Consumer<? super T> action) { /* */ }

    default Spliterator<T> spliterator() { /* */ }
}

Q3. What Are Static Class Members?

Static fields and methods of a class are not bound to a specific instance of a class. Instead, they are bound to the class object itself. The call of a static method or addressing a static field is resolved at compile time because, contrary to instance methods and fields, we don't need to walk the reference and determine an actual object we're referring to.
Q4. May a Class Be Declared Abstract If It Does Not Have Any Abstract Members? What Could Be the Purpose of Such Class?

Yes, a class can be declared abstract even if it does not contain any abstract members. As an abstract class, it cannot be instantiated, but it can serve as a root object of some hierarchy, providing methods that can be useful to its implementations.
Q5. What Is Constructor Chaining?

Constructor chaining is a way of simplifying object construction by providing multiple constructors that call each other in sequence.

The most specific constructor may take all possible arguments and may be used for the most detailed object configuration. A less specific constructor may call the more specific constructor by providing some of its arguments with default values. At the top of the chain, a no-argument constructor could instantiate an object with default values.

Here's an example with a class that models a discount in percents that are available within a certain amount of days. The default values of 10% and 2 days are used if we don't specify them when using a no-arg constructor:

public class Discount {

    private int percent;

    private int days;

    public Discount() {
        this(10);
    }

    public Discount(int percent) {
        this(percent, 2);
    }

    public Discount(int percent, int days) {
        this.percent = percent;
        this.days = days;
    }

}

Q6. What Is Overriding and Overloading of Methods? How Are They Different?

Overriding of a method is done in a subclass when you define a method with the same signature as in superclass. This allows the runtime to pick a method depending on the actual object type that you call the method on. Methods toString, equals, and hashCode are overridden quite often in subclasses.

Overloading of a method happens in the same class. Overloading occurs when you create a method with the same name but with different types or number of arguments. This allows you to execute a certain code depending on the types of arguments you provide, while the name of the method remains the same.

Here's an example of overloading in the java.io.Writer abstract class. The following methods are both named write, but one of them receives an int while another receives a char array.

public abstract class Writer {

    public void write(int c) throws IOException {
        // ...
    }

    public void write(char cbuf[]) throws IOException {
        // ...
    }

}

Q7. Can You Override a Static Method?

No, you can't. By definition, you can only override a method if its implementation is determined at runtime by the type of the actual instance (a process known as the dynamic method lookup). The static method implementation is determined at compile time using the type of the reference, so overriding would not make much sense anyway. Although you can add to subclass a static method with the exact same signature as in superclass, this is not technically overriding.
Q8. What Is an Immutable Class, and How Can You Create One?

An instance of an immutable class cannot be changed after it's created. By changing we mean mutating the state by modifying the values of the fields of the instance. Immutable classes have many advantages: they are thread-safe, and it is much easier to reason about them when you have no mutable state to consider.

To make a class immutable, you should ensure the following:

    All fields should be declared private and final; this infers that they should be initialized in the constructor and not changed ever since;
    The class should have no setters or other methods that mutate the values of the fields;
    All fields of the class that were passed via constructor should either be also immutable, or their values should be copied before field initialization (or else we could change the state of this class by holding on to these values and modifying them);
    The methods of the class should not be overridable; either all methods should be final, or the constructor should be private and only invoked via static factory method.

Q9. How Do You Compare Two Enum Values: With equals() or With ==?

Actually, you can use both. The enum values are objects, so they can be compared with equals(), but they are also implemented as static constants under the hood, so you might as well compare them with ==. This is mostly a matter of code style, but if you want to save character space (and possibly skip an unneeded method call), you should compare enums with ==.
Q10. What Is an Initializer Block? What Is a Static Initializer Block?

An initializer block is a curly-braced block of code in the class scope which is executed during the instance creation. You can use it to initialize fields with something more complex than in-place initialization one-liners.

Actually, the compiler just copies this block inside every constructor, so it is a nice way to extract common code from all constructors.

A static initializer block is a curly-braced block of code with the static modifier in front of it. It is executed once during the class loading and can be used for initializing static fields or for some side effects.
Q11. What Is a Marker Interface? What Are the Notable Examples of Marker Interfaces in Java?

A marker interface is an interface without any methods. It is usually implemented by a class or extended by another interface to signify a certain property. The most widely known marker interfaces in standard Java library are the following:

    Serializable is used to explicitly express that this class can be serialized;
    Cloneable allows cloning objects using the clone method (without Cloneable interface in place, this method throws a CloneNotSupportedException);
    Remote is used in RMI to specify an interface which methods could be called remotely.

Q12. What Is a Singleton and How Can It Be Implemented in Java?

Singleton is a pattern of object-oriented programming. A singleton class may only have one instance, usually globally visible and accessible.

There are multiple ways of creating a singleton in Java. The following is the most simple example with a static field that is initialized in-place. The initialization is thread-safe because static fields are guaranteed to be initialized in a thread-safe manner. The constructor is private, so there is no way for outer code to create more than one instance of the class.

public class SingletonExample {

    private static SingletonExample instance = new SingletonExample();

    private SingletonExample() {}

    public static SingletonExample getInstance() {
        return instance;
    }
}

But this approach could have a serious drawback — the instance would be instantiated when this class is first accessed. If initialization of this class is a heavy operation, and we would probably like to defer it until the instance is actually needed (possibly never), but at the same time keep it thread-safe. In this case, we should use a technique known as double-checked locking.
Q13. What Is a Var-Arg? What Are the Restrictions on a Var-Arg? How Can You Use It Inside the Method Body?

Var-arg is a variable-length argument for a method. A method may have only one var-arg, and it has to come last in the list of arguments. It is specified as a type name followed by an ellipsis and an argument name. Inside the method body, a var-arg is used as an array of specified type.

Here's an example from the standard library — the Collections.addAll method that receives a collection, a variable number of elements, and adds all elements to the collection:

public static <T> boolean addAll(
  Collection<? super T> c, T... elements) {
    boolean result = false;
    for (T element : elements)
        result |= c.add(element);
    return result;
}

Q14. Can You Access an Overridden Method of a Superclass? Can You Access an Overridden Method of a Super-Superclass in a Similar Way?

To access an overridden method of a superclass, you can use the super keyword. But you don't have a similar way of accessing the overridden method of a super-superclass.

As an example from the standard library, LinkedHashMap class extends HashMap and mostly re-uses its functionality, adding a linked list over its values to preserve iteration order. LinkedHashMap re-uses the clear method of its superclass and then clears head and tail references of its linked list:

public void clear() {
    super.clear();
    head = tail = null;
}

Next »
Java 8 Interview Questions(+ Answers)
« Previous
Java Concurrency Interview Questions (+ Answers)
Get started with Spring 5 and Spring Boot 2, through the Learn Spring course:
>> CHECK OUT THE COURSE
Learning to build your API
with Spring?
Download the E-book
Comments are closed on this article!
opt-in
Building a REST API with Spring 5?
Download the E-book
The Baeldung logo
Courses

    All Courses
    All Bulk Courses
    The Courses Platform

Series

    Java “Back to Basics” Tutorial
    Jackson JSON Tutorial
    HttpClient 4 Tutorial
    REST with Spring Tutorial
    Spring Persistence Tutorial
    Security with Spring
    Spring Reactive Tutorials

About

    About Baeldung
    The Full Archive
    Write for Baeldung
    Editors
    Jobs
    Our Partners
    Advertise on Baeldung

    Terms of Service Privacy Policy Company Info Contact 




The Baeldung Logo
Start Here
Courses ▼
Guides ▼
About ▼

Java 8 Interview Questions(+ Answers)

Last modified: August 3, 2021
by baeldung

    Java+ 

    InterviewJava 8 

Your logs should hold the key to the problem, right? It’s why we build intricate logging systems, create best practices on how and what to log in our teams and streamline as much of the adding, consuming, and analyzing our production logs as possible. But, the reality is that you can’t log all the things. It can’t be done. Not without producing literally unconscionable amounts of unnecessary log data.

There’s another option: Lightrun.
With Lightrun, you can add logs directly into production in a secure (i.e. without opening debug ports), read-only (i.e. without side effects), and real-time (i.e. no redeploying, restarting, or even stopping the running applications) way.
This article is part of a series:
1. Introduction

In this tutorial, we're going to explore some of the JDK8-related questions that might pop up during an interview.

Java 8 is a platform release packed with new language features and library classes. Most of these new features are geared towards achieving cleaner and more compact code, while some add new functionality that has never before been supported in Java.
Further reading:
Memory Management in Java Interview Questions (+Answers)
A set of popular Memory Management-related interview questions and of course answers.
Read more →
Java Collections Interview Questions
A set of practical Collections-related Java interview questions
Read more →
2. Java 8 General Knowledge
Q1. What New Features Were Added in Java 8?

Java 8 ships with several new features, but the most significant are the following:

    Lambda Expressions − a new language feature allowing us to treat actions as objects
    Method References − enable us to define Lambda Expressions by referring to methods directly using their names
    Optional − special wrapper class used for expressing optionality
    Functional Interface – an interface with maximum one abstract method; implementation can be provided using a Lambda Expression
    Default methods − give us the ability to add full implementations in interfaces besides abstract methods
    Nashorn, JavaScript Engine − Java-based engine for executing and evaluating JavaScript code
    Stream API − a special iterator class that allows us to process collections of objects in a functional manner
    Date API − an improved, immutable JodaTime-inspired Date API

Along with these new features, lots of feature enhancements are done under the hood at both the compiler and JVM level.
3. Method References
Q1. What Is a Method Reference?

A method reference is a Java 8 construct that can be used for referencing a method without invoking it. It's used for treating methods as Lambda Expressions. They only work as syntactic sugar to reduce the verbosity of some lambdas. This way the following code:

(o) -> o.toString();

Can become:

Object::toString();

A method reference can be identified by a double colon separating a class or object name, and the name of the method. It has different variations, such as constructor reference:

String::new;

Static method reference:

String::valueOf;

Bound instance method reference:

str::toString;

Unbound instance method reference:

String::toString;

We can read a detailed description of method references with full examples by following this link and this one.
Q2. What Is the Meaning of String::Valueof Expression?

It's a static method reference to the valueOf method of the String class.
4. Optional
Q1. What Is Optional? How Can It Be Used?

Optional is a new class in Java 8 that encapsulates an optional value, i.e. a value that is either there or not. It's a wrapper around an object, and we can think of it as a container of zero or one element.

Optional has a special Optional.empty() value instead of wrapped null. Thus it can be used instead of a nullable value to get rid of NullPointerException in many cases.

We can read a dedicated article about Optional here.

The main purpose of Optional, as designed by its creators, is to be a return type of methods that previously would return null. Such methods would require us to write boilerplate code to check the return value, and we could sometimes forget to do a defensive check. In Java 8, an Optional return type explicitly requires us to handle null or non-null wrapped values differently.

For instance, the Stream.min() method calculates the minimum value in a stream of values. But what if the stream is empty? If it wasn't for Optional, the method would return null or throw an exception.

However, it returns an Optional value, which may be Optional.empty() (the second case). This allows us to easily handle such cases:

int min1 = Arrays.stream(new int[]{1, 2, 3, 4, 5})
  .min()
  .orElse(0);
assertEquals(1, min1);

int min2 = Arrays.stream(new int[]{})
  .min()
  .orElse(0);
assertEquals(0, min2);

It's worth noting that Optional is not a general purpose class like Option in Scala. It's not recommended that we use it as a field value in entity classes, which is clearly indicated by it not implementing the Serializable interface.
5. Functional Interfaces
Q1. Describe Some of the Functional Interfaces in the Standard Library

There are a lot of functional interfaces in the java.util.function package. The more common ones include, but are not limited to:

    Function – it takes one argument and returns a result
    Consumer – it takes one argument and returns no result (represents a side effect)
    Supplier – it takes no arguments and returns a result
    Predicate – it takes one argument and returns a boolean
    BiFunction – it takes two arguments and returns a result
    BinaryOperator – it is similar to a BiFunction, taking two arguments and returning a result. The two arguments and the result are all of the same types.
    UnaryOperator – it is similar to a Function, taking a single argument and returning a result of the same type

For more on functional interfaces, see the article “Functional Interfaces in Java 8.”
Q2. What Is a Functional Interface? What Are the Rules of Defining a Functional Interface?

A functional interface is an interface with one single abstract method (default methods do not count), no more, no less.

Where an instance of such an interface is required, a Lambda Expression can be used instead. More formally put: Functional interfaces provide target types for lambda expressions and method references.

The arguments and return type of such an expression directly match those of the single abstract method.

For instance, the Runnable interface is a functional interface, so instead of:

Thread thread = new Thread(new Runnable() {
    public void run() {
        System.out.println("Hello World!");
    }
});

We could simply do:

Thread thread = new Thread(() -> System.out.println("Hello World!"));

Functional interfaces are usually annotated with the @FunctionalInterface annotation, which is informative and doesn't affect the semantics.
6. Default Method
Q1. What Is a Default Method and When Do We Use It?

A default method is a method with an implementation, which can be found in an interface.

We can use a default method to add a new functionality to an interface, while maintaining backward compatibility with classes that are already implementing the interface:

public interface Vehicle {
    public void move();
    default void hoot() {
        System.out.println("peep!");
    }
}

Usually when we add a new abstract method to an interface, all implementing classes will break until they implement the new abstract method. In Java 8, this problem was solved by using the default method.

For example, the Collection interface does not have a forEach method declaration. Thus adding such a method would simply break the whole collections API.

Java 8 introduced the default method so that the Collection interface can have a default implementation of the forEach method without requiring the classes implementing this interface to implement the same.
Q2. Will the Following Code Compile?

@FunctionalInterface
public interface Function2<T, U, V> {
    public V apply(T t, U u);

    default void count() {
        // increment counter
    }
}

Yes, the code will compile because it follows the functional interface specification of defining only a single abstract method. The second method, count, is a default method that does not increase the abstract method count.
7. Lambda Expressions
Q1. What Is a Lambda Expression and What Is It Used For?

In very simple terms, a lambda expression is a function that we can reference and pass around as an object.

Moreover, lambda expressions introduce functional style processing in Java, and facilitate the writing of compact and easy-to-read code.

As a result, lambda expressions are a natural replacement for anonymous classes such as method arguments. One of their main uses is to define inline implementations of functional interfaces.
Q2. Explain the Syntax and Characteristics of a Lambda Expression

A lambda expression consists of two parts, the parameter part and the expressions part separated by a forward arrow:

params -> expressions

Any lambda expression has the following characteristics:

    Optional type declaration – when declaring the parameters on the left-hand side of the lambda, we don't need to declare their types as the compiler can infer them from their values. So int param -> … and param ->… are all valid
    Optional parentheses – when only a single parameter is declared, we don't need to place it in parentheses. This means param -> … and (param) -> … are all valid, but when more than one parameter is declared, parentheses are required
    Optional curly braces – when the expressions part only has a single statement, there is no need for curly braces. This means that param – > statement and param – > {statement;} are all valid, but curly braces are required when there is more than one statement
    Optional return statement – when the expression returns a value and it is wrapped inside curly braces, then we don't need a return statement. That means (a, b) – > {return a+b;} and (a, b) – > {a+b;} are both valid

To read more about Lambda expressions, follow this link and this one.
8. Nashorn Javascript
Q1. What Is Nashorn in Java8?

Nashorn is the new Javascript processing engine for the Java platform that shipped with Java 8. Until JDK 7, the Java platform used Mozilla Rhino for the same purpose, as a Javascript processing engine.

Nashorn provides better compliance with the ECMA normalized JavaScript specification and better runtime performance than its predecessor.
Q2. What Is JJS?

In Java 8, jjs is the new executable or command line tool we use to execute Javascript code at the console.
9. Streams
Q1. What Is a Stream? How Does It Differ From a Collection?

In simple terms, a stream is an iterator whose role is to accept a set of actions to apply on each of the elements it contains.

The stream represents a sequence of objects from a source such as a collection, which supports aggregate operations. They were designed to make collection processing simple and concise. Contrary to the collections, the logic of iteration is implemented inside the stream, so we can use methods like map and flatMap for performing a declarative processing.

Additionally, the Stream API is fluent and allows pipelining:

int sum = Arrays.stream(new int[]{1, 2, 3})
  .filter(i -> i >= 2)
  .map(i -> i * 3)
  .sum();

Another important distinction from collections is that streams are inherently lazily loaded and processed.
Q2. What Is the Difference Between Intermediate and Terminal Operations?

We combine stream operations into pipelines to process streams. All operations are either intermediate or terminal.

Intermediate operations are those operations that return Stream itself, allowing for further operations on a stream.

These operations are always lazy, i.e. they do not process the stream at the call site. An intermediate operation can only process data when there is a terminal operation. Some of the intermediate operations are filter, map and flatMap.

In contrast, terminal operations terminate the pipeline and initiate stream processing. The stream is passed through all intermediate operations during terminal operation call. Terminal operations include forEach, reduce, Collect and sum.

To drive this point home, let's look at an example with side effects:

public static void main(String[] args) {
    System.out.println("Stream without terminal operation");
    
    Arrays.stream(new int[] { 1, 2, 3 }).map(i -> {
        System.out.println("doubling " + i);
        return i * 2;
    });
 
    System.out.println("Stream with terminal operation");
        Arrays.stream(new int[] { 1, 2, 3 }).map(i -> {
            System.out.println("doubling " + i);
            return i * 2;
    }).sum();
}

The output will be as follows:

Stream without terminal operation
Stream with terminal operation
doubling 1
doubling 2
doubling 3

As we can see, the intermediate operations are only triggered when a terminal operation exists.
Q3. What Is the Difference Between Map and flatMap Stream Operation?

There is a difference in signature between map and flatMap. Generally speaking, a map operation wraps its return value inside its ordinal type, while flatMap does not.

For example, in Optional, a map operation would return Optional<String> type, while flatMap would return String type.

So after mapping, we need to unwrap (read “flatten”) the object to retrieve the value, whereas after flat mapping, there is no such need as the object is already flattened. We apply the same concept to mapping and flat mapping in Stream.

Both map and flatMap are intermediate stream operations that receive a function and apply this function to all the elements of a stream.

The difference is that for the map, this function returns a value, but for flatMap, this function returns a stream. The flatMap operation “flattens” the streams into one.

Here's an example where we take a map of users' names and lists of phones and “flatten” it down to a list of phones of all the users using flatMap:

Map<String, List<String>> people = new HashMap<>();
people.put("John", Arrays.asList("555-1123", "555-3389"));
people.put("Mary", Arrays.asList("555-2243", "555-5264"));
people.put("Steve", Arrays.asList("555-6654", "555-3242"));

List<String> phones = people.values().stream()
  .flatMap(Collection::stream)
    .collect(Collectors.toList());

Q4. What Is Stream Pipelining in Java 8?

Stream pipelining is the concept of chaining operations together. We do this by splitting the operations that can happen on a stream into two categories: intermediate operations and terminal operations.

Each intermediate operation returns an instance of Stream itself when it runs. Therefore, we can set up an arbitrary number of intermediate operations to process data, forming a processing pipeline.

There must then be a terminal operation which returns a final value and terminates the pipeline.
10. Java 8 Date and Time API
Q1. Tell Us About the New Date and Time API in Java 8

A long-standing problem for Java developers has been the inadequate support for the date and time manipulations required by ordinary developers.

The existing classes such as java.util.Date and SimpleDateFormatter aren’t thread-safe, leading to potential concurrency issues for users.

Poor API design is also a reality in the old Java Data API. Here's just a quick example: years in java.util.Date start at 1900, months start at 1, and days start at 0, which is not very intuitive.

These issues and several others have led to the popularity of third-party date and time libraries, such as Joda-Time.

In order to address these problems and provide better support in JDK, a new date and time API, which is free of these problems, has been designed for Java SE 8 under the package java.time.
11. Conclusion

In this article, we explored several important technical interview questions with a bias on Java 8. This is by no means an exhaustive list, but it contains questions that we think are most likely to appear in each new feature of Java 8.

Even if we're just starting out, ignorance of Java 8 isn't a good way to go into an interview, especially when Java appears strongly on a resume. It is therefore important that we take some time to understand the answers to these questions and possibly do more research.

Good luck in the interview.
Next »
Memory Management in Java Interview Questions (+Answers)
« Previous
Java Class Structure and Initialization Interview Questions
Get started with Spring 5 and Spring Boot 2, through the Learn Spring course:
>> CHECK OUT THE COURSE
Learning to build your API
with Spring?
Download the E-book
Comments are closed on this article!
opt-in
Building a REST API with Spring 5?
Download the E-book
The Baeldung logo
Courses

    All Courses
    All Bulk Courses
    The Courses Platform

Series

    Java “Back to Basics” Tutorial
    Jackson JSON Tutorial
    HttpClient 4 Tutorial
    REST with Spring Tutorial
    Spring Persistence Tutorial
    Security with Spring
    Spring Reactive Tutorials

About

    About Baeldung
    The Full Archive
    Write for Baeldung
    Editors
    Jobs
    Our Partners
    Advertise on Baeldung

    Terms of Service Privacy Policy Company Info Contact 





The Baeldung Logo
Start Here
Courses ▼
Guides ▼
About ▼

Memory Management in Java Interview Questions (+Answers)

Last modified: August 2, 2019
by baeldung

    Java+ 

    Interview 

Your logs should hold the key to the problem, right? It’s why we build intricate logging systems, create best practices on how and what to log in our teams and streamline as much of the adding, consuming, and analyzing our production logs as possible. But, the reality is that you can’t log all the things. It can’t be done. Not without producing literally unconscionable amounts of unnecessary log data.

There’s another option: Lightrun.
With Lightrun, you can add logs directly into production in a secure (i.e. without opening debug ports), read-only (i.e. without side effects), and real-time (i.e. no redeploying, restarting, or even stopping the running applications) way.
This article is part of a series:
1. Introduction

In this article, we'll explore some memory management questions that frequently pop up during Java developer interviews. Memory management is an area that not so many developers are familiar with.

In fact, developers don't generally have to deal with this concept directly – as the JVM takes care of the nitty-gritty details. Unless something is going seriously wrong, even seasoned developers may not have accurate information about memory management at their fingertips.

On the other hand, these concepts are actually quite prevalent in interviews – so let's jump right in.
2. Questions
Q1. What Does the Statement “Memory Is Managed in Java” Mean?

Memory is the key resource an application requires to run effectively and like any resource, it is scarce. As such, its allocation and deallocation to and from applications or different parts of an application require a lot of care and consideration.

However, in Java, a developer does not need to explicitly allocate and deallocate memory – the JVM and more specifically the Garbage Collector – has the duty of handling memory allocation so that the developer doesn't have to.

This is contrary to what happens in languages like C where a programmer has direct access to memory and literally references memory cells in his code, creating a lot of room for memory leaks.
Q2. What Is Garbage Collection and What Are Its Advantages?

Garbage collection is the process of looking at heap memory, identifying which objects are in use and which are not, and deleting the unused objects.

An in-use object, or a referenced object, means that some part of your program still maintains a pointer to that object. An unused object, or unreferenced object, is no longer referenced by any part of your program. So the memory used by an unreferenced object can be reclaimed.

The biggest advantage of garbage collection is that it removes the burden of manual memory allocation/deallocation from us so that we can focus on solving the problem at hand.
Q3. Are There Any Disadvantages of Garbage Collection?

Yes. Whenever the garbage collector runs, it has an effect on the application's performance. This is because all other threads in the application have to be stopped to allow the garbage collector thread to effectively do its work.

Depending on the requirements of the application, this can be a real problem that is unacceptable by the client. However, this problem can be greatly reduced or even eliminated through skillful optimization and garbage collector tuning and using different GC algorithms.
Q4. What Is the Meaning of the Term “Stop-The-World”?

When the garbage collector thread is running, other threads are stopped, meaning the application is stopped momentarily. This is analogous to house cleaning or fumigation where occupants are denied access until the process is complete.

Depending on the needs of an application, “stop the world” garbage collection can cause an unacceptable freeze. This is why it is important to do garbage collector tuning and JVM optimization so that the freeze encountered is at least acceptable.
Q5. What Are Stack and Heap? What Is Stored in Each of These Memory Structures, and How Are They Interrelated?

The stack is a part of memory that contains information about nested method calls down to the current position in the program. It also contains all local variables and references to objects on the heap defined in currently executing methods.

This structure allows the runtime to return from the method knowing the address whence it was called, and also clear all local variables after exiting the method. Every thread has its own stack.

The heap is a large bulk of memory intended for allocation of objects. When you create an object with the new keyword, it gets allocated on the heap. However, the reference to this object lives on the stack.
Q6. What Is Generational Garbage Collection and What Makes It a Popular Garbage Collection Approach?

Generational garbage collection can be loosely defined as the strategy used by the garbage collector where the heap is divided into a number of sections called generations, each of which will hold objects according to their “age” on the heap.

Whenever the garbage collector is running, the first step in the process is called marking. This is where the garbage collector identifies which pieces of memory are in use and which are not. This can be a very time-consuming process if all objects in a system must be scanned.

As more and more objects are allocated, the list of objects grows and grows leading to longer and longer garbage collection time. However, empirical analysis of applications has shown that most objects are short-lived.

With generational garbage collection, objects are grouped according to their “age” in terms of how many garbage collection cycles they have survived. This way, the bulk of the work spread across various minor and major collection cycles.

Today, almost all garbage collectors are generational. This strategy is so popular because, over time, it has proven to be the optimal solution.
Q7. Describe in Detail How Generational Garbage Collection Works

To properly understand how generational garbage collection works, it is important to first remember how Java heap is structured to facilitate generational garbage collection.

The heap is divided up into smaller spaces or generations. These spaces are Young Generation, Old or Tenured Generation, and Permanent Generation.

The young generation hosts most of the newly created objects. An empirical study of most applications shows that majority of objects are quickly short lived and therefore, soon become eligible for collection. Therefore, new objects start their journey here and are only “promoted” to the old generation space after they have attained a certain “age”.

The term “age” in generational garbage collection refers to the number of collection cycles the object has survived.

The young generation space is further divided into three spaces: an Eden space and two survivor spaces such as Survivor 1 (s1) and Survivor 2 (s2).

The old generation hosts objects that have lived in memory longer than a certain “age”. The objects that survived garbage collection from the young generation are promoted to this space. It is generally larger than the young generation. As it is bigger in size, the garbage collection is more expensive and occurs less frequently than in the young generation.

The permanent generation or more commonly called, PermGen, contains metadata required by the JVM to describe the classes and methods used in the application. It also contains the string pool for storing interned strings. It is populated by the JVM at runtime based on classes in use by the application. In addition, platform library classes and methods may be stored here.

First, any new objects are allocated to the Eden space. Both survivor spaces start out empty. When the Eden space fills up, a minor garbage collection is triggered. Referenced objects are moved to the first survivor space. Unreferenced objects are deleted.

During the next minor GC, the same thing happens to the Eden space. Unreferenced objects are deleted and referenced objects are moved to a survivor space. However, in this case, they are moved to the second survivor space (S2).

In addition, objects from the last minor GC in the first survivor space (S1) have their age incremented and are moved to S2. Once all surviving objects have been moved to S2, both S1 and Eden space are cleared. At this point, S2 contains objects with different ages.

At the next minor GC, the same process is repeated. However this time the survivor spaces switch. Referenced objects are moved to S1 from both Eden and S2. Surviving objects are aged. Eden and S2 are cleared.

After every minor garbage collection cycle, the age of each object is checked. Those that have reached a certain arbitrary age, for example, 8, are promoted from the young generation to the old or tenured generation. For all subsequent minor GC cycles, objects will continue to be promoted to the old generation space.

This pretty much exhausts the process of garbage collection in the young generation. Eventually, a major garbage collection will be performed on the old generation which cleans up and compacts that space. For each major GC, there are several minor GCs.
Q8. When Does an Object Become Eligible for Garbage Collection? Describe How the Gc Collects an Eligible Object?

An object becomes eligible for Garbage collection or GC if it is not reachable from any live threads or by any static references.

The most straightforward case of an object becoming eligible for garbage collection is if all its references are null. Cyclic dependencies without any live external reference are also eligible for GC. So if object A references object B and object B references Object A and they don't have any other live reference then both Objects A and B will be eligible for Garbage collection.

Another obvious case is when a parent object is set to null. When a kitchen object internally references a fridge object and a sink object, and the kitchen object is set to null, both fridge and sink will become eligible for garbage collection alongside their parent, kitchen.
Q9. How Do You Trigger Garbage Collection from Java Code?

You, as Java programmer, can not force garbage collection in Java; it will only trigger if JVM thinks it needs a garbage collection based on Java heap size.

Before removing an object from memory garbage collection thread invokes finalize()method of that object and gives an opportunity to perform any sort of cleanup required. You can also invoke this method of an object code, however, there is no guarantee that garbage collection will occur when you call this method.

Additionally, there are methods like System.gc() and Runtime.gc() which is used to send request of Garbage collection to JVM but it’s not guaranteed that garbage collection will happen.
Q10. What Happens When There Is Not Enough Heap Space to Accommodate Storage of New Objects?

If there is no memory space for creating a new object in Heap, Java Virtual Machine throws OutOfMemoryError or more specifically java.lang.OutOfMemoryError heap space.
Q11. Is It Possible to «Resurrect» an Object That Became Eligible for Garbage Collection?

When an object becomes eligible for garbage collection, the GC has to run the finalize method on it. The finalize method is guaranteed to run only once, thus the GC flags the object as finalized and gives it a rest until the next cycle.

In the finalize method you can technically “resurrect” an object, for example, by assigning it to a static field. The object would become alive again and non-eligible for garbage collection, so the GC would not collect it during the next cycle.

The object, however, would be marked as finalized, so when it would become eligible again, the finalize method would not be called. In essence, you can turn this “resurrection” trick only once for the lifetime of the object. Beware that this ugly hack should be used only if you really know what you're doing — however, understanding this trick gives some insight into how the GC works.
Q12. Describe Strong, Weak, Soft and Phantom References and Their Role in Garbage Collection.

Much as memory is managed in Java, an engineer may need to perform as much optimization as possible to minimize latency and maximize throughput, in critical applications. Much as it is impossible to explicitly control when garbage collection is triggered in the JVM, it is possible to influence how it occurs as regards the objects we have created.

Java provides us with reference objects to control the relationship between the objects we create and the garbage collector.

By default, every object we create in a Java program is strongly referenced by a variable:

StringBuilder sb = new StringBuilder();

In the above snippet, the new keyword creates a new StringBuilder object and stores it on the heap. The variable sb then stores a strong reference to this object. What this means for the garbage collector is that the particular StringBuilder object is not eligible for collection at all due to a strong reference held to it by sb. The story only changes when we nullify sb like this:

sb = null;

After calling the above line, the object will then be eligible for collection.

We can change this relationship between the object and the garbage collector by explicitly wrapping it inside another reference object which is located inside java.lang.ref package.

A soft reference can be created to the above object like this:

StringBuilder sb = new StringBuilder();
SoftReference<StringBuilder> sbRef = new SoftReference<>(sb);
sb = null;

In the above snippet, we have created two references to the StringBuilder object. The first line creates a strong reference sb and the second line creates a soft reference sbRef. The third line should make the object eligible for collection but the garbage collector will postpone collecting it because of sbRef.

The story will only change when memory becomes tight and the JVM is on the brink of throwing an OutOfMemory error. In other words, objects with only soft references are collected as a last resort to recover memory.

A weak reference can be created in a similar manner using WeakReference class. When sb is set to null and the StringBuilder object only has a weak reference, the JVM's garbage collector will have absolutely no compromise and immediately collect the object at the very next cycle.

A phantom reference is similar to a weak reference and an object with only phantom references will be collected without waiting. However, phantom references are enqueued as soon as their objects are collected. We can poll the reference queue to know exactly when the object was collected.
Q13. Suppose We Have a Circular Reference (Two Objects That Reference Each Other). Could Such Pair of Objects Become Eligible for Garbage Collection and Why?

Yes, a pair of objects with a circular reference can become eligible for garbage collection. This is because of how Java's garbage collector handles circular references. It considers objects live not when they have any reference to them, but when they are reachable by navigating the object graph starting from some garbage collection root (a local variable of a live thread or a static field). If a pair of objects with a circular reference is not reachable from any root, it is considered eligible for garbage collection.
Q14. How Are Strings Represented in Memory?

A String instance in Java is an object with two fields: a char[] value field and an int hash field. The value field is an array of chars representing the string itself, and the hash field contains the hashCode of a string which is initialized with zero, calculated during the first hashCode() call and cached ever since. As a curious edge case, if a hashCode of a string has a zero value, it has to be recalculated each time the hashCode() is called.

Important thing is that a String instance is immutable: you can't get or modify the underlying char[] array. Another feature of strings is that the static constant strings are loaded and cached in a string pool. If you have multiple identical String objects in your source code, they are all represented by a single instance at runtime.
Q15. What Is a Stringbuilder and What Are Its Use Cases? What Is the Difference Between Appending a String to a Stringbuilder and Concatenating Two Strings with a + Operator? How Does Stringbuilder Differ from Stringbuffer?

StringBuilder allows manipulating character sequences by appending, deleting and inserting characters and strings. This is a mutable data structure, as opposed to the String class which is immutable.

When concatenating two String instances, a new object is created, and strings are copied. This could bring a huge garbage collector overhead if we need to create or modify a string in a loop. StringBuilder allows handling string manipulations much more efficiently.

StringBuffer is different from StringBuilder in that it is thread-safe. If you need to manipulate a string in a single thread, use StringBuilder instead.
3. Conclusion

In this article, we have covered some of the most common questions that frequently appear in Java engineer interviews. Questions about memory management are mostly asked for Senior Java Developer candidates as the interviewer expects that you have built non-trivial applications which are, a lot of times, plagued by memory issues.

This should not be treated as an exhaustive list of questions, but rather a launch pad for further research. We, at Baeldung, wish you success in any upcoming interviews.
Next »
Java Generics Interview Questions (+Answers)
« Previous
Java 8 Interview Questions(+ Answers)
Get started with Spring 5 and Spring Boot 2, through the Learn Spring course:
>> CHECK OUT THE COURSE
Learning to build your API
with Spring?
Download the E-book
1 Comment
Oldest
Comments are closed on this article!
opt-in
Building a REST API with Spring 5?
Download the E-book
The Baeldung logo
Courses

    All Courses
    All Bulk Courses
    The Courses Platform

Series

    Java “Back to Basics” Tutorial
    Jackson JSON Tutorial
    HttpClient 4 Tutorial
    REST with Spring Tutorial
    Spring Persistence Tutorial
    Security with Spring
    Spring Reactive Tutorials

About

    About Baeldung
    The Full Archive
    Write for Baeldung
    Editors
    Jobs
    Our Partners
    Advertise on Baeldung

    Terms of Service Privacy Policy Company Info Contact 




The Baeldung Logo
Start Here
Courses ▼
Guides ▼
About ▼

Java Generics Interview Questions (+Answers)

Last modified: May 6, 2021
by baeldung

    Java+ 

    Interview 

Your logs should hold the key to the problem, right? It’s why we build intricate logging systems, create best practices on how and what to log in our teams and streamline as much of the adding, consuming, and analyzing our production logs as possible. But, the reality is that you can’t log all the things. It can’t be done. Not without producing literally unconscionable amounts of unnecessary log data.

There’s another option: Lightrun.
With Lightrun, you can add logs directly into production in a secure (i.e. without opening debug ports), read-only (i.e. without side effects), and real-time (i.e. no redeploying, restarting, or even stopping the running applications) way.
This article is part of a series:
1. Introduction

In this article, we'll go through some example Java generics interview questions and answers.

Generics are a core concept in Java, first introduced in Java 5. Because of this, nearly all Java codebases will make use of them, almost guaranteeing that a developer will run into them at some point. This is why it's essential to understand them correctly, and is why they are more than likely to be asked about during an interview process.
2. Questions
Q1. What Is a Generic Type Parameter?

Type is the name of a class or interface. As implied by the name, a generic type parameter is when a type can be used as a parameter in a class, method or interface declaration.

Let's start with a simple example, one without generics, to demonstrate this:

public interface Consumer {
    public void consume(String parameter)
}

In this case, the method parameter type of the consume() method is String. It is not parameterized and not configurable.

Now let's replace our String type with a generic type that we will call T. It is named like this by convention:

public interface Consumer<T> {
    public void consume(T parameter)
}

When we implement our consumer, we can provide the type that we want it to consume as an argument. This is a generic type parameter:

public class IntegerConsumer implements Consumer<Integer> {
    public void consume(Integer parameter)
}

In this case, now we can consume integers. We can swap out this type for whatever we require.
Q2. What Are Some Advantages of Using Generic Types?

One advantage of using generics is avoiding casts and provide type safety. This is particularly useful when working with collections. Let's demonstrate this:

List list = new ArrayList();
list.add("foo");
Object o = list.get(0);
String foo = (String) o;

In our example, the element type in our list is unknown to the compiler. This means that the only thing that can be guaranteed is that it is an object. So when we retrieve our element, an Object is what we get back. As the authors of the code, we know it's a String, but we have to cast our object to one to fix the problem explicitly. This produces a lot of noise and boilerplate.

Next, if we start to think about the room for manual error, the casting problem gets worse. What if we accidentally had an Integer in our list?

list.add(1)
Object o = list.get(0);
String foo = (String) o;

In this case, we would get a ClassCastException at runtime, as an Integer cannot be cast to String.

Now, let's try repeating ourselves, this time using generics:

List<String> list = new ArrayList<>();
list.add("foo");
String o = list.get(0);    // No cast
Integer foo = list.get(0); // Compilation error

As we can see, by using generics we have a compile type check which prevents ClassCastExceptions and removes the need for casting.

The other advantage is to avoid code duplication. Without generics, we have to copy and paste the same code but for different types. With generics, we do not have to do this. We can even implement algorithms that apply to generic types.
Q3. What Is Type Erasure?

It's important to realize that generic type information is only available to the compiler, not the JVM. In other words, type erasure means that generic type information is not available to the JVM at runtime, only compile time.

The reasoning behind major implementation choice is simple – preserving backward compatibility with older versions of Java. When a generic code is compiled into bytecode, it will be as if the generic type never existed. This means that the compilation will:

    Replace generic types with objects
    Replace bounded types (More on these in a later question) with the first bound class
    Insert the equivalent of casts when retrieving generic objects.

It's important to understand type erasure. Otherwise, a developer might get confused and think they'd be able to get the type at runtime:

public foo(Consumer<T> consumer) {
   Type type = consumer.getGenericTypeParameter()
}

The above example is a pseudo code equivalent of what things might look like without type erasure, but unfortunately, it is impossible. Once again, the generic type information is not available at runtime.
Q4. If a Generic Type Is Omitted When Instantiating an Object, Will the Code Still Compile?

As generics did not exist before Java 5, it is possible not to use them at all. For example, generics were retrofitted to most of the standard Java classes such as collections. If we look at our list from question one, then we will see that we already have an example of omitting the generic type:

List list = new ArrayList();

Despite being able to compile, it's still likely that there will be a warning from the compiler. This is because we are losing the extra compile-time check that we get from using generics.

The point to remember is that while backward compatibility and type erasure make it possible to omit generic types, it is bad practice.
Q5. How Does a Generic Method Differ from a Generic Type?

A generic method is where a type parameter is introduced to a method, living within the scope of that method. Let's try this with an example:

public static <T> T returnType(T argument) { 
    return argument; 
}

We've used a static method but could have also used a non-static one if we wished. By leveraging type inference (covered in the next question), we can invoke this like any ordinary method, without having to specify any type arguments when we do so.
Q6. What Is Type Inference?

Type inference is when the compiler can look at the type of a method argument to infer a generic type. For example, if we passed in T to a method which returns T, then the compiler can figure out the return type. Let's try this out by invoking our generic method from the previous question:

Integer inferredInteger = returnType(1);
String inferredString = returnType("String");

As we can see, there's no need for a cast, and no need to pass in any generic type argument. The argument type only infers the return type.
Q7. What Is a Bounded Type Parameter?

So far all our questions have covered generic types arguments which are unbounded. This means that our generic type arguments could be any type that we want.

When we use bounded parameters, we are restricting the types that can be used as generic type arguments.

As an example, let's say we want to force our generic type always to be a subclass of animal:

public abstract class Cage<T extends Animal> {
    abstract void addAnimal(T animal)
}

By using extends, we are forcing T to be a subclass of animal. We could then have a cage of cats:

Cage<Cat> catCage;

But we could not have a cage of objects, as an object is not a subclass of an animal:

Cage<Object> objectCage; // Compilation error

One advantage of this is that all the methods of animal are available to the compiler. We know our type extends it, so we could write a generic algorithm which operates on any animal. This means we don't have to reproduce our method for different animal subclasses:

public void firstAnimalJump() {
    T animal = animals.get(0);
    animal.jump();
}

Q8. Is It Possible to Declared a Multiple Bounded Type Parameter?

Declaring multiple bounds for our generic types is possible. In our previous example, we specified a single bound, but we could also specify more if we wish:

public abstract class Cage<T extends Animal & Comparable>

In our example, the animal is a class and comparable is an interface. Now, our type must respect both of these upper bounds. If our type were a subclass of animal but did not implement comparable, then the code would not compile. It's also worth remembering that if one of the upper bounds is a class, it must be the first argument.
Q9. What Is a Wildcard Type?

A wildcard type represents an unknown type. It's detonated with a question mark as follows:

public static void consumeListOfWildcardType(List<?> list)

Here, we are specifying a list which could be of any type. We could pass a list of anything into this method.
Q10. What Is an Upper Bounded Wildcard?

An upper bounded wildcard is when a wildcard type inherits from a concrete type. This is particularly useful when working with collections and inheritance.

Let's try demonstrating this with a farm class which will store animals, first without the wildcard type:

public class Farm {
  private List<Animal> animals;

  public void addAnimals(Collection<Animal> newAnimals) {
    animals.addAll(newAnimals);
  }
}

If we had multiple subclasses of animal, such as cat and dog, we might make the incorrect assumption that we can add them all to our farm:

farm.addAnimals(cats); // Compilation error
farm.addAnimals(dogs); // Compilation error

This is because the compiler expects a collection of the concrete type animal, not one it subclasses.

Now, let's introduce an upper bounded wildcard to our add animals method:

public void addAnimals(Collection<? extends Animal> newAnimals)

Now if we try again, our code will compile. This is because we are now telling the compiler to accept a collection of any subtype of animal.
Q11. What Is an Unbounded Wildcard?

An unbounded wildcard is a wildcard with no upper or lower bound, that can represent any type.

It's also important to know that the wildcard type is not synonymous to object. This is because a wildcard can be any type whereas an object type is specifically an object (and cannot be a subclass of an object). Let's demonstrate this with an example:

List<?> wildcardList = new ArrayList<String>(); 
List<Object> objectList = new ArrayList<String>(); // Compilation error

Again, the reason the second line does not compile is that a list of objects is required, not a list of strings. The first line compiles because a list of any unknown type is acceptable.
Q12. What Is a Lower Bounded Wildcard?

A lower bounded wildcard is when instead of providing an upper bound, we provide a lower bound by using the super keyword. In other words, a lower bounded wildcard means we are forcing the type to be a superclass of our bounded type. Let's try this with an example:

public static void addDogs(List<? super Animal> list) {
   list.add(new Dog("tom"))
}

By using super, we could call addDogs on a list of objects:

ArrayList<Object> objects = new ArrayList<>();
addDogs(objects);

This makes sense, as an object is a superclass of animal. If we did not use the lower bounded wildcard, the code would not compile, as a list of objects is not a list of animals.

If we think about it, we wouldn’t be able to add a dog to a list of any subclass of animal, such as cats, or even dogs. Only a superclass of animal. For example, this would not compile:

ArrayList<Cat> objects = new ArrayList<>();
addDogs(objects);

Q13. When Would You Choose to Use a Lower Bounded Type vs. an Upper Bounded Type?

When dealing with collections, a common rule for selecting between upper or lower bounded wildcards is PECS. PECS stands for producer extends, consumer super.

This can be easily demonstrated through the use of some standard Java interfaces and classes.

Producer extends just means that if you are creating a producer of a generic type, then use the extends keyword. Let's try applying this principle to a collection, to see why it makes sense:

public static void makeLotsOfNoise(List<? extends Animal> animals) {
    animals.forEach(Animal::makeNoise);   
}

Here, we want to call makeNoise() on each animal in our collection. This means our collection is a producer, as all we are doing with it is getting it to return animals for us to perform our operation on. If we got rid of extends, we wouldn't be able to pass in lists of cats, dogs or any other subclasses of animals. By applying the producer extends principle, we have the most flexibility possible.

Consumer super means the opposite to producer extends. All it means is that if we are dealing with something which consumes elements, then we should use the super keyword. We can demonstrate this by repeating our previous example:

public static void addCats(List<? super Animal> animals) {
    animals.add(new Cat());   
}

We are only adding to our list of animals, so our list of animals is a consumer. This is why we use the super keyword. It means that we could pass in a list of any superclass of animal, but not a subclass. For example, if we tried passing in a list of dogs or cats then the code would not compile.

The final thing to consider is what to do if a collection is both a consumer and a producer. An example of this might be a collection where elements are both added and removed. In this case, an unbounded wildcard should be used.
Q14. Are There Any Situations Where Generic Type Information Is Available at Runtime?

There is one situation where a generic type is available at runtime. This is when a generic type is part of the class signature like so:

public class CatCage implements Cage<Cat>

By using reflection, we get this type parameter:

(Class<T>) ((ParameterizedType) getClass()
  .getGenericSuperclass()).getActualTypeArguments()[0];

This code is somewhat brittle. For example, it's dependant on the type parameter being defined on the immediate superclass. But, it demonstrates the JVM does have this type information.
Next »
Java Flow Control Interview Questions (+ Answers)
« Previous
Memory Management in Java Interview Questions (+Answers)
Get started with Spring 5 and Spring Boot 2, through the Learn Spring course:
>> CHECK OUT THE COURSE
Learning to build your API
with Spring?
Download the E-book
2 Comments
Oldest
Comments are closed on this article!
opt-in
Building a REST API with Spring 5?
Download the E-book
The Baeldung logo
Courses

    All Courses
    All Bulk Courses
    The Courses Platform

Series

    Java “Back to Basics” Tutorial
    Jackson JSON Tutorial
    HttpClient 4 Tutorial
    REST with Spring Tutorial
    Spring Persistence Tutorial
    Security with Spring
    Spring Reactive Tutorials

About

    About Baeldung
    The Full Archive
    Write for Baeldung
    Editors
    Jobs
    Our Partners
    Advertise on Baeldung

    Terms of Service Privacy Policy Company Info Contact 




The Baeldung Logo
Start Here
Courses ▼
Guides ▼
About ▼

Java Flow Control Interview Questions (+ Answers)

Last modified: August 5, 2021
by baeldung

    Java+ 

    Interview 

Your logs should hold the key to the problem, right? It’s why we build intricate logging systems, create best practices on how and what to log in our teams and streamline as much of the adding, consuming, and analyzing our production logs as possible. But, the reality is that you can’t log all the things. It can’t be done. Not without producing literally unconscionable amounts of unnecessary log data.

There’s another option: Lightrun.
With Lightrun, you can add logs directly into production in a secure (i.e. without opening debug ports), read-only (i.e. without side effects), and real-time (i.e. no redeploying, restarting, or even stopping the running applications) way.
This article is part of a series:
1. Introduction

Control flow statements allow developers to use decision making, looping and branching to conditionally change the flow of execution of particular blocks of code.

In this article, we’ll go through some flow control interview questions that might pop up during an interview and, where appropriate; we'll implement examples to understand their answers better.
2. Questions
Q1. Describe the if-then and if-then-else Statements. What Types of Expressions Can Be Used as Conditions?

Both statements tell our program to execute the code inside of them only if a particular condition evaluates to true. However, the if-then-else statement provides a secondary path of execution in case the if clause evaluates to false:

if (age >= 21) {
    // ...
} else {
    // ...
}

Unlike other programming languages, Java only supports boolean expressions as conditions. If we try to use a different type of expression, we'll get a compilation error.
Q2. Describe the switch Statement. What Object Types Can Be Used in the switch Clause?

Switch allows the selection of several execution paths based on a variables' value.

Each path is labeled with case or default, the switch statement evaluates each case expression for a match and executes all statements that follow the matching label until a break statement is found. If it can't find a match, the default block will be executed instead:

switch (yearsOfJavaExperience) {
    case 0:
        System.out.println("Student");
        break;
    case 1:
        System.out.println("Junior");
        break;
    case 2:
        System.out.println("Middle");
        break;
    default:
        System.out.println("Senior");
}

We can use byte, short, char, int, their wrapped versions, enums and Strings as switch values.
Q3. What Happens When We Forget to Put a break Statement in a case Clause of a switch?

The switch statement falls-trough. This means that it will continue the execution of all case labels until if finds a break statement, even though those labels don't match the expression's value.

Here's an example to demonstrate this:

int operation = 2;
int number = 10;

switch (operation) {
    case 1:
        number = number + 10;
        break;
    case 2:
        number = number - 4;
    case 3:
        number = number / 3;
    case 4:
        number = number * 10;
        break;
}

After running the code, number holds the value 20, instead of 6. This can be useful in situations when we want to associate the same action with multiple cases.
Q4. When Is It Preferable to Use a Switch Over an If-Then-Else Statement and Vice Versa?

A switch statement is better suited when testing a single variable against many single values or when several values will execute the same code:

switch (month) {
    case 1:
    case 3:
    case 5:
    case 7:
    case 8:
    case 10:
    case 12:
        days = 31;
        break;
case 2:
    days = 28;
    break;
default:
    days = 30;
}

An if-then-else statement is preferable when we need to check ranges of values or multiple conditions:

if (aPassword == null || aPassword.isEmpty()) {
    // empty password
} else if (aPassword.length() < 8 || aPassword.equals("12345678")) {
    // weak password
} else {
    // good password
}

Q5. What Types of Loops Does Java Support?

Java offers three different types of loops: for, while, and do-while.

A for loop provides a way to iterate over a range of values. It's most useful when we know in advance how many times a task is going to be repeated:

for (int i = 0; i < 10; i++) {
     // ...
}

A while loop can execute a block of statements while a particular condition is true:

while (iterator.hasNext()) {
    // ...
}

A do-while is a variation of a while statement in which the evaluation of the boolean expression is at the bottom of the loop. This guarantees that the code will execute at least once:

do {
    // ...
} while (choice != -1);

Q6. What Is an enhanced for Loop?

Is another syntax of the for statement designed to iterate through all the elements of a collection, array, enum or any object implementing the Iterable interface:

for (String aString : arrayOfStrings) {
    // ...
}

Q7. How Can You Exit Anticipatedly From a Loop?

Using the break statement, we can terminate the execution of a loop immediately:

for (int i = 0; ; i++) {
    if (i > 10) {
        break;
    }
}

Q8. What Is the Difference Between an Unlabeled and a Labeled break Statement?

An unlabeled break statement terminates the innermost switch, for, while or do-while statement, whereas a labeled break ends the execution of an outer statement.

Let's create an example to demonstrate this:

int[][] table = { { 1, 2, 3 }, { 25, 37, 49 }, { 55, 68, 93 } };
boolean found = false;
int loopCycles = 0;

outer: for (int[] rows : table) {
    for (int row : rows) {
        loopCycles++;
        if (row == 37) {
            found = true;
            break outer;
        }
    }
}

When the number 37 is found, the labeled break statement terminates the outermost for loop, and no more cycles are executed. Thus, loopCycles ends with the value of 5.

However, the unlabeled break only ends the innermost statement, returning the flow of control to the outermost for that continues the loop to the next row in the table variable, making the loopCycles end with a value of 8.
Q9. What Is the Difference Between an Unlabeled and a Labeled continue Statement?

An unlabeled continue statement skips to the end of the current iteration in the innermost for, while, or do-while loop, whereas a labeled continue skips to an outer loop marked with the given label.

Here's an example that demonstrates this:

int[][] table = { { 1, 15, 3 }, { 25, 15, 49 }, { 15, 68, 93 } };
int loopCycles = 0;

outer: for (int[] rows : table) {
    for (int row : rows) {
        loopCycles++;
        if (row == 15) {
            continue outer;
        }
    }
}

The reasoning is the same as in the previous question. The labeled continue statement terminates the outermost for loop.

Thus, loopCycles ends holding the value 5, whereas the unlabeled version only terminates the innermost statement, making the loopCycles end with a value of 9.
Q10. Describe the Execution Flow Inside a try-catch-finally Construct.

When a program has entered the try block, and an exception is thrown inside it, the execution of the try block is interrupted, and the flow of control continues with a catch block that can handle the exception being thrown.

If no such block exists then the current method execution stops, and the exception is thrown to the previous method on the call stack. Alternatively, if no exception occurs, all catch blocks are ignored, and program execution continues normally.

A finally block is always executed whether an exception was thrown or not inside the body of the try block.
Q11. In Which Situations the finally Block May Not Be Executed?

When the JVM is terminated while executing the try or catch blocks, for instance, by calling System.exit(), or when the executing thread is interrupted or killed, then the finally block is not executed.
Q12. What Is the Result of Executing the Following Code?

public static int assignment() {
    int number = 1;
    try {
        number = 3;
        if (true) {
            throw new Exception("Test Exception");
        }
        number = 2;
    } catch (Exception ex) {
        return number;
    } finally {
        number = 4;
    }
    return number;
}

System.out.println(assignment());

The code outputs the number 3. Even though the finally block is always executed, this happens only after the try block exits.

In the example, the return statement is executed before the try-catch block ends. Thus, the assignment to number in the finally block makes no effect, since the variable is already returned to the calling code of the assignment method.
Q13. In Which Situations try-finally Block Might Be Used Even When Exceptions Might Not Be Thrown?

This block is useful when we want to ensure we don't accidentally bypass the clean up of resources used in the code by encountering a break, continue or return statement:

HeavyProcess heavyProcess = new HeavyProcess();
try {
    // ...
    return heavyProcess.heavyTask();
} finally {
    heavyProcess.doCleanUp();
}

Also, we may face situations in which we can't locally handle the exception being thrown, or we want the current method to throw the exception still while allowing us to free up resources:

public void doDangerousTask(Task task) throws ComplicatedException {
    try {
        // ...
        task.gatherResources();
        if (task.isComplicated()) {
            throw new ComplicatedException("Too difficult");
        }
        // ...
    } finally {
        task.freeResources();
    }
}

Q14. How Does try-with-resources Work?

The try-with-resources statement declares and initializes one or more resources before executing the try block and closes them automatically at the end of the statement regardless of whether the block completed normally or abruptly. Any object implementing AutoCloseable or Closeable interfaces can be used as a resource:

try (StringWriter writer = new StringWriter()) {
    writer.write("Hello world!");
}

3. Conclusion

In this article, we covered some of the most frequently asked questions appearing in technical interviews for Java developers, regarding control flow statements. This should only be treated as the start of further research and not as an exhaustive list.

Good luck in your interview.
Next »
Java Exceptions Interview Questions (+ Answers)
« Previous
Java Generics Interview Questions (+Answers)
Get started with Spring 5 and Spring Boot 2, through the Learn Spring course:
>> CHECK OUT THE COURSE
Learning to build your API
with Spring?
Download the E-book
Comments are closed on this article!
opt-in
Building a REST API with Spring 5?
Download the E-book
The Baeldung logo
Courses

    All Courses
    All Bulk Courses
    The Courses Platform

Series

    Java “Back to Basics” Tutorial
    Jackson JSON Tutorial
    HttpClient 4 Tutorial
    REST with Spring Tutorial
    Spring Persistence Tutorial
    Security with Spring
    Spring Reactive Tutorials

About

    About Baeldung
    The Full Archive
    Write for Baeldung
    Editors
    Jobs
    Our Partners
    Advertise on Baeldung

    Terms of Service Privacy Policy Company Info Contact 






The Baeldung Logo
Start Here
Courses ▼
Guides ▼
About ▼

Java Exceptions Interview Questions (+ Answers)

Last modified: April 24, 2020
by baeldung

    Java+ 

    ExceptionInterview 

Your logs should hold the key to the problem, right? It’s why we build intricate logging systems, create best practices on how and what to log in our teams and streamline as much of the adding, consuming, and analyzing our production logs as possible. But, the reality is that you can’t log all the things. It can’t be done. Not without producing literally unconscionable amounts of unnecessary log data.

There’s another option: Lightrun.
With Lightrun, you can add logs directly into production in a secure (i.e. without opening debug ports), read-only (i.e. without side effects), and real-time (i.e. no redeploying, restarting, or even stopping the running applications) way.
This article is part of a series:
1. Overview

Exceptions are an essential topic that every Java developer should be familiar with. This article provides answers to some of the questions that might pop up during an interview.
2. Questions
Q1. What Is an Exception?

An exception is an abnormal event that occurs during the execution of a program and disrupts the normal flow of the program's instructions.
Q2. What Is the Purpose of the Throw and Throws Keywords?

The throws keyword is used to specify that a method may raise an exception during its execution. It enforces explicit exception handling when calling a method:

public void simpleMethod() throws Exception {
    // ...
}

The throw keyword allows us to throw an exception object to interrupt the normal flow of the program. This is most commonly used when a program fails to satisfy a given condition:

if (task.isTooComplicated()) {
    throw new TooComplicatedException("The task is too complicated");
}

Q3. How Can You Handle an Exception?

By using a try-catch-finally statement:

try {
    // ...
} catch (ExceptionType1 ex) {
    // ...
} catch (ExceptionType2 ex) {
    // ...
} finally {
    // ...
}

The block of code in which an exception may occur is enclosed in a try block. This block is also called “protected” or “guarded” code.

If an exception occurs, the catch block that matches the exception being thrown is executed, if not, all catch blocks are ignored.

The finally block is always executed after the try block exits, whether an exception was thrown or not inside it.
Q4. How Can You Catch Multiple Exceptions?

There are three ways of handling multiple exceptions in a block of code.

The first is to use a catch block that can handle all exception types being thrown:

try {
    // ...
} catch (Exception ex) {
    // ...
}

You should keep in mind that the recommended practice is to use exception handlers that are as accurate as possible.

Exception handlers that are too broad can make your code more error-prone, catch exceptions that weren't anticipated, and cause unexpected behavior in your program.

The second way is implementing multiple catch blocks:

try {
    // ...
} catch (FileNotFoundException ex) {
    // ...
} catch (EOFException ex) {
    // ...
}

Note that, if the exceptions have an inheritance relationship; the child type must come first and the parent type later. If we fail to do this, it will result in a compilation error.

The third is to use a multi-catch block:

try {
    // ...
} catch (FileNotFoundException | EOFException ex) {
    // ...
}

This feature, first introduced in Java 7; reduces code duplication and makes it easier to maintain.
Q5. What Is the Difference Between a Checked and an Unchecked Exception?

A checked exception must be handled within a try-catch block or declared in a throws clause; whereas an unchecked exception is not required to be handled nor declared.

Checked and unchecked exceptions are also known as compile-time and runtime exceptions respectively.

All exceptions are checked exceptions, except those indicated by Error, RuntimeException, and their subclasses.
Q6. What Is the Difference Between an Exception and Error?

An exception is an event that represents a condition from which is possible to recover, whereas error represents an external situation usually impossible to recover from.

All errors thrown by the JVM are instances of Error or one of its subclasses, the more common ones include but are not limited to:

    OutOfMemoryError – thrown when the JVM cannot allocate more objects because it is out memory, and the garbage collector was unable to make more available
    StackOverflowError – occurs when the stack space for a thread has run out, typically because an application recurses too deeply
    ExceptionInInitializerError – signals that an unexpected exception occurred during the evaluation of a static initializer
    NoClassDefFoundError – is thrown when the classloader tries to load the definition of a class and couldn't find it, usually because the required class files were not found in the classpath
    UnsupportedClassVersionError – occurs when the JVM attempts to read a class file and determines that the version in the file is not supported, normally because the file was generated with a newer version of Java

Although an error can be handled with a try statement, this is not a recommended practice since there is no guarantee that the program will be able to do anything reliably after the error was thrown.
Q7. What Exception Will Be Thrown Executing the Following Code Block?

Integer[][] ints = { { 1, 2, 3 }, { null }, { 7, 8, 9 } };
System.out.println("value = " + ints[1][1].intValue());

It throws an ArrayIndexOutOfBoundsException since we're trying to access a position greater than the length of the array.
Q8. What Is Exception Chaining?

Occurs when an exception is thrown in response to another exception. This allows us to discover the complete history of our raised problem:

try {
    task.readConfigFile();
} catch (FileNotFoundException ex) {
    throw new TaskException("Could not perform task", ex);
}

Q9. What Is a Stacktrace and How Does It Relate to an Exception?

A stack trace provides the names of the classes and methods that were called, from the start of the application to the point an exception occurred.

It's a very useful debugging tool since it enables us to determine exactly where the exception was thrown in the application and the original causes that led to it.
Q10. Why Would You Want to Subclass an Exception?

If the exception type isn't represented by those that already exist in the Java platform, or if you need to provide more information to client code to treat it in a more precise manner, then you should create a custom exception.

Deciding whether a custom exception should be checked or unchecked depends entirely on the business case. However, as a rule of thumb; if the code using your exception can be expected to recover from it, then create a checked exception otherwise make it unchecked.

Also, you should inherit from the most specific Exception subclass that closely relates to the one you want to throw. If there is no such class, then choose Exception as the parent.
Q11. What Are Some Advantages of Exceptions?

Traditional error detection and handling techniques often lead to spaghetti code hard to maintain and difficult to read. However, exceptions enable us to separate the core logic of our application from the details of what to do when something unexpected happens.

Also, since the JVM searches backward through the call stack to find any methods interested in handling a particular exception; we gain the ability to propagate an error up in the call stack without writing additional code.

Also, because all exceptions thrown in a program are objects, they can be grouped or categorized based on its class hierarchy. This allows us to catch a group of exceptions in a single exception handler by specifying the exception's superclass in the catch block.
Q12. Can You Throw Any Exception Inside a Lambda Expression's Body?

When using a standard functional interface already provided by Java, you can only throw unchecked exceptions because standard functional interfaces do not have a “throws” clause in method signatures:

List<Integer> integers = Arrays.asList(3, 9, 7, 0, 10, 20);
integers.forEach(i -> {
    if (i == 0) {
        throw new IllegalArgumentException("Zero not allowed");
    }
    System.out.println(Math.PI / i);
});

However, if you are using a custom functional interface, throwing checked exceptions is possible:

@FunctionalInterface
public static interface CheckedFunction<T> {
    void apply(T t) throws Exception;
}

public void processTasks(
  List<Task> taks, CheckedFunction<Task> checkedFunction) {
    for (Task task : taks) {
        try {
            checkedFunction.apply(task);
        } catch (Exception e) {
            // ...
        }
    }
}

processTasks(taskList, t -> {
    // ...
    throw new Exception("Something happened");
});

Q13. What Are the Rules We Need to Follow When Overriding a Method That Throws an Exception?

Several rules dictate how exceptions must be declared in the context of inheritance.

When the parent class method doesn't throw any exceptions, the child class method can't throw any checked exception, but it may throw any unchecked.

Here's an example code to demonstrate this:

class Parent {
    void doSomething() {
        // ...
    }
}

class Child extends Parent {
    void doSomething() throws IllegalArgumentException {
        // ...
    }
}

The next example will fail to compile since the overriding method throws a checked exception not declared in the overridden method:

class Parent {
    void doSomething() {
        // ...
    }
}

class Child extends Parent {
    void doSomething() throws IOException {
        // Compilation error
    }
}

When the parent class method throws one or more checked exceptions, the child class method can throw any unchecked exception; all, none or a subset of the declared checked exceptions, and even a greater number of these as long as they have the same scope or narrower.

Here's an example code that successfully follows the previous rule:

class Parent {
    void doSomething() throws IOException, ParseException {
        // ...
    }

    void doSomethingElse() throws IOException {
        // ...
    }
}

class Child extends Parent {
    void doSomething() throws IOException {
        // ...
    }

    void doSomethingElse() throws FileNotFoundException, EOFException {
        // ...
    }
}

Note that both methods respect the rule. The first throws fewer exceptions than the overridden method, and the second, even though it throws more; they're narrower in scope.

However, if we try to throw a checked exception that the parent class method doesn't declare or we throw one with a broader scope; we'll get a compilation error:

class Parent {
    void doSomething() throws FileNotFoundException {
        // ...
    }
}

class Child extends Parent {
    void doSomething() throws IOException {
        // Compilation error
    }
}

When the parent class method has a throws clause with an unchecked exception, the child class method can throw none or any number of unchecked exceptions, even though they are not related.

Here's an example that honors the rule:

class Parent {
    void doSomething() throws IllegalArgumentException {
        // ...
    }
}

class Child extends Parent {
    void doSomething()
      throws ArithmeticException, BufferOverflowException {
        // ...
    }
}

Q14. Will the Following Code Compile?

void doSomething() {
    // ...
    throw new RuntimeException(new Exception("Chained Exception"));
}

Yes. When chaining exceptions, the compiler only cares about the first one in the chain and, because it detects an unchecked exception, we don't need to add a throws clause.
Q15. Is There Any Way of Throwing a Checked Exception from a Method That Does Not Have a Throws Clause?

Yes. We can take advantage of the type erasure performed by the compiler and make it think we are throwing an unchecked exception, when, in fact; we're throwing a checked exception:

public <T extends Throwable> T sneakyThrow(Throwable ex) throws T {
    throw (T) ex;
}

public void methodWithoutThrows() {
    this.<RuntimeException>sneakyThrow(new Exception("Checked Exception"));
}

3. Conclusion

In this article, we’ve explored some of the questions that are likely to appear in technical interviews for Java developers, regarding exceptions. This is not an exhaustive list, and it should be treated only as the start of further research.

We, at Baeldung, wish you success in any upcoming interviews.
Next »
Java Annotations Interview Questions (+ Answers)
« Previous
Java Flow Control Interview Questions (+ Answers)
Get started with Spring 5 and Spring Boot 2, through the Learn Spring course:
>> CHECK OUT THE COURSE
Learning to build your API
with Spring?
Download the E-book
Comments are closed on this article!
opt-in
Building a REST API with Spring 5?
Download the E-book
The Baeldung logo
Courses

    All Courses
    All Bulk Courses
    The Courses Platform

Series

    Java “Back to Basics” Tutorial
    Jackson JSON Tutorial
    HttpClient 4 Tutorial
    REST with Spring Tutorial
    Spring Persistence Tutorial
    Security with Spring
    Spring Reactive Tutorials

About

    About Baeldung
    The Full Archive
    Write for Baeldung
    Editors
    Jobs
    Our Partners
    Advertise on Baeldung

    Terms of Service Privacy Policy Company Info Contact 






The Baeldung Logo
Start Here
Courses ▼
Guides ▼
About ▼

Java Annotations Interview Questions (+ Answers)

Last modified: July 11, 2019
by baeldung

    Java+ 

    Interview 

Your logs should hold the key to the problem, right? It’s why we build intricate logging systems, create best practices on how and what to log in our teams and streamline as much of the adding, consuming, and analyzing our production logs as possible. But, the reality is that you can’t log all the things. It can’t be done. Not without producing literally unconscionable amounts of unnecessary log data.

There’s another option: Lightrun.
With Lightrun, you can add logs directly into production in a secure (i.e. without opening debug ports), read-only (i.e. without side effects), and real-time (i.e. no redeploying, restarting, or even stopping the running applications) way.
This article is part of a series:
1. Introduction

Annotations have been around since Java 5, and nowadays, they are ubiquitous programming constructs that allow enriching the code.

In this article, we'll review some of the questions, regarding annotations; that are often asked on technical interviews and, where appropriate; we'll implement examples to understand their answers better.
2. Questions
Q1. What Are Annotations? What Are Their Typical Use Cases?

Annotations are metadata bound to elements of the source code of a program and have no effect on the operation of the code they operate.

Their typical uses cases are:

    Information for the compiler – with annotations, the compiler can detect errors or suppress warnings
    Compile-time and deployment-time processing – software tools can process annotations and generate code, configuration files, etc.
    Runtime processing – annotations can be examined at runtime to customize the behavior of a program

Q2. Describe Some Useful Annotations from the Standard Library.

There are several annotations in the java.lang and java.lang.annotation packages, the more common ones include but not limited to:

    @Override – marks that a method is meant to override an element declared in a superclass. If it fails to override the method correctly, the compiler will issue an error
    @Deprecated – indicates that element is deprecated and should not be used. The compiler will issue a warning if the program uses a method, class, or field marked with this annotation
    @SuppressWarnings – tells the compiler to suppress specific warnings. Most commonly used when interfacing with legacy code written before generics appeared
    @FunctionalInterface – introduced in Java 8, indicates that the type declaration is a functional interface and whose implementation can be provided using a Lambda Expression

Q3. How Can You Create an Annotation?

Annotations are a form of an interface where the keyword interface is preceded by @, and whose body contains annotation type element declarations that look very similar to methods:

public @interface SimpleAnnotation {
    String value();

    int[] types();
}

After the annotation is defined, yon can start using it in through your code:

@SimpleAnnotation(value = "an element", types = 1)
public class Element {
    @SimpleAnnotation(value = "an attribute", types = { 1, 2 })
    public Element nextElement;
}

Note that, when providing multiple values for array elements, you must enclose them in brackets.

Optionally, default values can be provided as long as they are constant expressions to the compiler:

public @interface SimpleAnnotation {
    String value() default "This is an element";

    int[] types() default { 1, 2, 3 };
}

Now, you can use the annotation without those elements:

@SimpleAnnotation
public class Element {
    // ...
}

Or only some of them:

@SimpleAnnotation(value = "an attribute")
public Element nextElement;

Q4. What Object Types Can Be Returned from an Annotation Method Declaration?

The return type must be a primitive, String, Class, Enum, or an array of one of the previous types. Otherwise, the compiler will throw an error.

Here's an example code that successfully follows this principle:

enum Complexity {
    LOW, HIGH
}

public @interface ComplexAnnotation {
    Class<? extends Object> value();

    int[] types();

    Complexity complexity();
}

The next example will fail to compile since Object is not a valid return type:

public @interface FailingAnnotation {
    Object complexity();
}

Q5. Which Program Elements Can Be Annotated?

Annotations can be applied in several places throughout the source code. They can be applied to declarations of classes, constructors, and fields:

@SimpleAnnotation
public class Apply {
    @SimpleAnnotation
    private String aField;

    @SimpleAnnotation
    public Apply() {
        // ...
    }
}

Methods and their parameters:

@SimpleAnnotation
public void aMethod(@SimpleAnnotation String param) {
    // ...
}

Local variables, including a loop and resource variables:

@SimpleAnnotation
int i = 10;

for (@SimpleAnnotation int j = 0; j < i; j++) {
    // ...
}

try (@SimpleAnnotation FileWriter writer = getWriter()) {
    // ...
} catch (Exception ex) {
    // ...
}

Other annotation types:

@SimpleAnnotation
public @interface ComplexAnnotation {
    // ...
}

And even packages, through the package-info.java file:

@PackageAnnotation
package com.baeldung.interview.annotations;

As of Java 8, they can also be applied to the use of types. For this to work, the annotation must specify an @Target annotation with a value of ElementType.USE:

@Target(ElementType.TYPE_USE)
public @interface SimpleAnnotation {
    // ...
}

Now, the annotation can be applied to class instance creation:

new @SimpleAnnotation Apply();

Type casts:

aString = (@SimpleAnnotation String) something;

Implements clause:

public class SimpleList<T>
  implements @SimpleAnnotation List<@SimpleAnnotation T> {
    // ...
}

And throws clause:

void aMethod() throws @SimpleAnnotation Exception {
    // ...
}

Q6. Is There a Way to Limit the Elements in Which an Annotation Can Be Applied?

Yes, the @Target annotation can be used for this purpose. If we try to use an annotation in a context where it is not applicable, the compiler will issue an error.

Here's an example to limit the usage of the @SimpleAnnotation annotation to field declarations only:

@Target(ElementType.FIELD)
public @interface SimpleAnnotation {
    // ...
}

We can pass multiple constants if we want to make it applicable in more contexts:

@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PACKAGE })

We can even make an annotation so it cannot be used to annotate anything. This may come in handy when the declared types are intended solely for use as a member type in complex annotations:

@Target({})
public @interface NoTargetAnnotation {
    // ...
}

Q7. What Are Meta-Annotations?

Are annotations that apply to other annotations.

All annotations that aren't marked with @Target, or are marked with it but include ANNOTATION_TYPE constant are also meta-annotations:

@Target(ElementType.ANNOTATION_TYPE)
public @interface SimpleAnnotation {
    // ...
}

Q8. What Are Repeating Annotations?

These are annotations that can be applied more than once to the same element declaration.

For compatibility reasons, since this feature was introduced in Java 8, repeating annotations are stored in a container annotation that is automatically generated by the Java compiler. For the compiler to do this, there are two steps to declared them.

First, we need to declare a repeatable annotation:

@Repeatable(Schedules.class)
public @interface Schedule {
    String time() default "morning";
}

Then, we define the containing annotation with a mandatory value element, and whose type must be an array of the repeatable annotation type:

public @interface Schedules {
    Schedule[] value();
}

Now, we can use @Schedule multiple times:

@Schedule
@Schedule(time = "afternoon")
@Schedule(time = "night")
void scheduledMethod() {
    // ...
}

Q9. How Can You Retrieve Annotations? How Does This Relate to Its Retention Policy?

You can use the Reflection API or an annotation processor to retrieve annotations.

The @Retention annotation and its RetentionPolicy parameter affect how you can retrieve them. There are three constants in RetentionPolicy enum:

    RetentionPolicy.SOURCE – makes the annotation to be discarded by the compiler but annotation processors can read them
    RetentionPolicy.CLASS – indicates that the annotation is added to the class file but not accessible through reflection
    RetentionPolicy.RUNTIME –Annotations are recorded in the class file by the compiler and retained by the JVM at runtime so that they can be read reflectively

Here's an example code to create an annotation that can be read at runtime:

@Retention(RetentionPolicy.RUNTIME)
public @interface Description {
    String value();
}

Now, annotations can be retrieved through reflection:

Description description
  = AnnotatedClass.class.getAnnotation(Description.class);
System.out.println(description.value());

An annotation processor can work with RetentionPolicy.SOURCE, this is described in the article Java Annotation Processing and Creating a Builder.

RetentionPolicy.CLASS is usable when you're writing a Java bytecode parser.
Q10. Will the Following Code Compile?

@Target({ ElementType.FIELD, ElementType.TYPE, ElementType.FIELD })
public @interface TestAnnotation {
    int[] value() default {};
}

No. It's a compile-time error if the same enum constant appears more than once in an @Target annotation.

Removing the duplicate constant will make the code to compile successfully:

@Target({ ElementType.FIELD, ElementType.TYPE})

Q11. Is It Possible to Extend Annotations?

No. Annotations always extend java.lang.annotation.Annotation, as stated in the Java Language Specification.

If we try to use the extends clause in an annotation declaration, we'll get a compilation error:

public @interface AnAnnotation extends OtherAnnotation {
    // Compilation error
}

Conclusion

In this article, we covered some of the frequently asked questions appearing in technical interviews for Java developers, regarding annotations. This is by no means an exhaustive list, and should only be considered as the start of further research.

We, at Baeldung, wish you success in any upcoming interviews.
Next »
Top Spring Framework Interview Questions
« Previous
Java Exceptions Interview Questions (+ Answers)
Get started with Spring 5 and Spring Boot 2, through the Learn Spring course:
>> CHECK OUT THE COURSE
Learning to build your API
with Spring?
Download the E-book
3 Comments
Oldest
Comments are closed on this article!
opt-in
Building a REST API with Spring 5?
Download the E-book
The Baeldung logo
Courses

    All Courses
    All Bulk Courses
    The Courses Platform

Series

    Java “Back to Basics” Tutorial
    Jackson JSON Tutorial
    HttpClient 4 Tutorial
    REST with Spring Tutorial
    Spring Persistence Tutorial
    Security with Spring
    Spring Reactive Tutorials

About

    About Baeldung
    The Full Archive
    Write for Baeldung
    Editors
    Jobs
    Our Partners
    Advertise on Baeldung

    Terms of Service Privacy Policy Company Info Contact 




The Baeldung Logo
Start Here
Courses ▼
Guides ▼
About ▼

Top Spring Framework Interview Questions

Last modified: July 30, 2021
by baeldung

    Spring+ 

    Interview 

Get started with Spring 5 and Spring Boot 2, through the reference Learn Spring course:
>> LEARN SPRING
This article is part of a series:
Table of Contents

    1. Overview
    2. Spring Core
    Q1. What Is Spring Framework?
    Q2. What Are the Benefits of Using Spring?
    Q3.What Spring Sub-Projects Do You Know? Describe Them Briefly.
    Q4. What Is Dependency Injection?
    Q5. How Can We Inject Beans in Spring?
    Q6. Which Is the Best Way of Injecting Beans and Why?
    Q7. What Is the Difference Between BeanFactory and ApplicationContext?
    Q8.What Is a Spring Bean?
    Q9. What Is the Default Bean Scope in Spring Framework?
    Q10. How to Define the Scope of a Bean?
    Q11. Are Singleton Beans Thread-Safe?
    Q12. What Does the Spring Bean Life Cycle Look Like?
    Q13. What Is the Spring Java-Based Configuration?
    Q14. Can We Have Multiple Spring Configuration Files in One Project?
    Q15. What Is Spring Security?
    Q16. What Is Spring Boot?
    Q17. Name Some of the Design Patterns Used in the Spring Framework?
    Q18. How Does the Scope Prototype Work?

 

    3. Spring Web MVC
    Q19. How to Get ServletContext and ServletConfig Objects in a Spring Bean?
    Q20. What Is a Controller in Spring MVC?
    Q21. How Does the @RequestMapping Annotation Work?

 

    4. Spring Data Access
    Q22. What Is Spring Jdbctemplate Class and How to Use It?
    Q23. How to Enable Transactions in Spring and What Are Their Benefits?
    Q24. What Is Spring DAO?

 

    5. Spring Aspect-Oriented Programming (AOP)
    Q25. What Is Aspect-Oriented Programming?
    Q26. What Are Aspect, Advice, Pointcut, and JoinPoint in AOP?
    Q27. What Is Weaving?

 

    6. Spring 5
    Q28. What Is Reactive Programming?
    Q29. What Is Spring WebFlux?
    Q30. What Are the Mono and Flux Types?
    Q31. What Is the Use of WebClient and WebTestClient?
    Q32. What Are the Disadvantages of Using Reactive Streams?
    Q33. Is Spring 5 Compatible With Older Versions of Java?
    Q34. How Ow Spring 5 Integrates With JDK 9 Modularity?
    Q35. Can We Use Both Web MVC and WebFlux in the Same Application?

 

    7. Conclusion

1. Overview

In this tutorial, we're going to look at some of the most common Spring-related questions that might pop up during a job interview.
Further reading:
Java Interview Questions
Learn the answers to common Java interview questions
Read more →
Java 8 Interview Questions(+ Answers)
A set of popular Java8-related interview questions and of course answers.
Read more →
Java Collections Interview Questions
A set of practical Collections-related Java interview questions
Read more →
2. Spring Core
Q1. What Is Spring Framework?

Spring is the most broadly used framework for the development of Java Enterprise Edition applications. Further, the core features of Spring can be used in developing any Java application.

We use its extensions for building various web applications on top of the Jakarta EE platform. We can also just use its dependency injection provisions in simple standalone applications.
Q2. What Are the Benefits of Using Spring?

Spring targets to make Jakarta EE development easier, so let's look at the advantages:

    Lightweight – There is a slight overhead of using the framework in development.
    Inversion of Control (IoC) – Spring container takes care of wiring dependencies of various objects instead of creating or looking for dependent objects.
    Aspect-Oriented Programming (AOP) – Spring supports AOP to separate business logic from system services.
    IoC container – manages Spring Bean life cycle and project-specific configurations
    MVC framework – used to create web applications or RESTful web services, capable of returning XML/JSON responses
    Transaction management – reduces the amount of boilerplate code in JDBC operations, file uploading, etc., either by using Java annotations or by Spring Bean XML configuration file
    Exception Handling – Spring provides a convenient API for translating technology-specific exceptions into unchecked exceptions.

Q3. What Spring Sub-Projects Do You Know? Describe Them Briefly.

    Core – a key module that provides fundamental parts of the framework, such as IoC or DI
    JDBC – enables a JDBC-abstraction layer that removes the need to do JDBC coding for specific vendor databases
    ORM integration – provides integration layers for popular object-relational mapping APIs, such as JPA, JDO and Hibernate
    Web – a web-oriented integration module that provides multipart file upload, Servlet listeners and web-oriented application context functionalities
    MVC framework – a web module implementing the Model View Controller design pattern
    AOP module – aspect-oriented programming implementation allowing the definition of clean method-interceptors and pointcuts

Q4. What Is Dependency Injection?

Dependency injection, an aspect of Inversion of Control (IoC), is a general concept stating that we do not create our objects manually but instead describe how they should be created. Then an IoC container will instantiate required classes if needed.

For more details, please look here.
Q5. How Can We Inject Beans in Spring?

A few different options exist in order to inject Spring beans:

    Setter injection
    Constructor injection
    Field injection

The configuration can be done using XML files or annotations.

For more details, check this article.
Q6. Which Is the Best Way of Injecting Beans and Why?

The recommended approach is to use constructor arguments for mandatory dependencies and setters for optional ones. This is because constructor injection allows injecting values to immutable fields and makes testing easier.
Q7. What Is the Difference Between BeanFactory and ApplicationContext?

BeanFactory is an interface representing a container that provides and manages bean instances. The default implementation instantiates beans lazily when getBean() is called.

In contrast, ApplicationContext is an interface representing a container holding all information, metadata and beans in the application. It also extends the BeanFactory interface, but the default implementation instantiates beans eagerly when the application starts. However, this behavior can be overridden for individual beans.

For all differences, please refer to the documentation.
Q8. What Is a Spring Bean?

The Spring Beans are Java Objects that are initialized by the Spring IoC container.
Q9. What Is the Default Bean Scope in Spring Framework?

By default, a Spring Bean is initialized as a singleton.
Q10. How to Define the Scope of a Bean?

In order to set Spring Bean's scope, we can use @Scope annotation or “scope” attribute in XML configuration files. Note that there are five supported scopes:

    Singleton
    Prototype
    Request
    Session
    Global-session

For differences, please look here.
Q11. Are Singleton Beans Thread-Safe?

No, singleton beans are not thread-safe, as thread safety is about execution, whereas the singleton is a design pattern focusing on creation. Thread safety depends only on the bean implementation itself.
Q12. What Does the Spring Bean Life Cycle Look Like?

First, a Spring bean needs to be instantiated based on Java or XML bean definition. It may also be required to perform some initialization to get it into a usable state. After that, when the bean is no longer required, it will be removed from the IoC container.

The whole cycle with all initialization methods is shown in the image (source):
Q13. What Is the Spring Java-Based Configuration?

It's one of the ways of configuring Spring-based applications in a type-safe manner. It's an alternative to the XML-based configuration.

Also, to migrate a project from XML to Java config, please refer to this article.
Q14. Can We Have Multiple Spring Configuration Files in One Project?

Yes, in large projects, having multiple Spring configurations is recommended to increase maintainability and modularity.

We can load multiple Java-based configuration files:

@Configuration
@Import({MainConfig.class, SchedulerConfig.class})
public class AppConfig {

Or we can load one XML file that will contain all other configs:

ApplicationContext context = new ClassPathXmlApplicationContext("spring-all.xml");

And inside this XML file we'll have the following:

<import resource="main.xml"/>
<import resource="scheduler.xml"/>

Q15. What Is Spring Security?

Spring Security is a separate module of the Spring framework that focuses on providing authentication and authorization methods in Java applications. It also takes care of most of the common security vulnerabilities such as CSRF attacks.

To use Spring Security in web applications, we can get started with the simple annotation @EnableWebSecurity.

For more information, we have a whole series of articles related to security.
Q16. What Is Spring Boot?

Spring Boot is a project that provides a pre-configured set of frameworks to reduce boilerplate configuration. This way, we can have a Spring application up and running with the smallest amount of code.
Q17. Name Some of the Design Patterns Used in the Spring Framework?

    Singleton Pattern – singleton-scoped beans
    Factory Pattern – Bean Factory classes
    Prototype Pattern – prototype-scoped beans
    Adapter Pattern – Spring Web and Spring MVC
    Proxy Pattern – Spring Aspect-Oriented Programming support
    Template Method Pattern – JdbcTemplate, HibernateTemplate, etc.
    Front Controller – Spring MVC DispatcherServlet
    Data Access Object – Spring DAO support
    Model View Controller – Spring MVC

Q18. How Does the Scope Prototype Work?

Scope prototype means that every time we call for an instance of the Bean, Spring will create a new instance and return it. This differs from the default singleton scope, where a single object instance is instantiated once per Spring IoC container.
3. Spring Web MVC
Q19. How to Get ServletContext and ServletConfig Objects in a Spring Bean?

We can do either by implementing Spring-aware interfaces. The complete list is available here.

We could also use @Autowired annotation on those beans:

@Autowired
ServletContext servletContext;

@Autowired
ServletConfig servletConfig;

Q20. What Is a Controller in Spring MVC?

Simply put, all the requests processed by the DispatcherServlet are directed to classes annotated with @Controller. Each controller class maps one or more requests to methods that process and execute the requests with provided inputs.

To take a step back, we recommend having a look at the concept of the Front Controller in the typical Spring MVC architecture.
Q21. How Does the @RequestMapping Annotation Work?

The @RequestMapping annotation is used to map web requests to Spring Controller methods. In addition to simple use cases, we can use it for mapping of HTTP headers, binding parts of the URI with @PathVariable, and working with URI parameters and the @RequestParam annotation.

More details on @RequestMapping are available here.

For more Spring MVC questions, please check out our article on Spring MVC interview questions.
4. Spring Data Access
Q22. What Is Spring JdbcTemplate Class and How to Use It?

The Spring JDBC template is the primary API through which we can access database operations logic that we’re interested in:

    Creation and closing of connections
    Executing statements and stored procedure calls
    Iterating over the ResultSet and returning results

In order to use it, we'll need to define the simple configuration of DataSource:

@Configuration
@ComponentScan("org.baeldung.jdbc")
public class SpringJdbcConfig {
    @Bean
    public DataSource mysqlDataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("com.mysql.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/springjdbc");
        dataSource.setUsername("guest_user");
        dataSource.setPassword("guest_password");
 
        return dataSource;
    }
}

For further explanation, check out this quick article.
Q23. How to Enable Transactions in Spring and What Are Their Benefits?

There are two distinct ways to configure Transactions — with annotations or by using Aspect-Oriented Programming (AOP) — each with their advantages.

Here are the benefits of using Spring Transactions, according to the official docs:

    Provide a consistent programming model across different transaction APIs such as JTA, JDBC, Hibernate, JPA and JDO
    Support declarative transaction management
    Provide a simpler API for programmatic transaction management than some complex transaction APIs such as JTA
    Integrate very well with Spring's various data access abstractions

Q24. What Is Spring DAO?

Spring Data Access Object (DAO) is Spring's support provided to work with data access technologies like JDBC, Hibernate and JPA in a consistent and easy way.

There is an entire series discussing persistence in Spring that provides a more in-depth look.
5. Spring Aspect-Oriented Programming
Q25. What Is Aspect-Oriented Programming (AOP)?

Aspects enable the modularization of cross-cutting concerns such as transaction management that span multiple types and objects by adding extra behavior to already existing code without modifying affected classes.

Here is the example of aspect-based execution time logging.
Q26. What Are Aspect, Advice, Pointcut and JoinPoint in AOP?

    Aspect – a class that implements cross-cutting concerns, such as transaction management
    Advice – the methods that get executed when a specific JoinPoint with matching Pointcut is reached in the application
    Pointcut – a set of regular expressions that are matched with JoinPoint to determine whether Advice needs to be executed or not
    JoinPoint – a point during the execution of a program, such as the execution of a method or the handling of an exception

Q27. What Is Weaving?

According to the official docs, weaving is a process that links aspects with other application types or objects to create an advised object. This can be done at compile time, load time, or runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime.
6. Spring 5
Q28. What Is Reactive Programming?

Reactive programming is about non-blocking, event-driven applications that scale with a small number of threads, with back pressure being a key ingredient that aims to ensure producers don't overwhelm consumers.

These are the primary benefits of reactive programming:

    Increased utilization of computing resources on multicore and multi-CPU hardware
    Increased performance by reducing serialization

Reactive programming is generally event-driven, in contrast to reactive systems, which are message-driven. So, using reactive programming does not mean we're building a reactive system, which is an architectural style.

However, reactive programming may be used as a means to implement reactive systems if we follow the Reactive Manifesto, which is quite vital to understand.

Based on this, reactive systems have four important characteristics:

    Responsive – The system should respond in a timely manner.
    Resilient – In case the system faces any failure, it should stay responsive.
    Elastic – Reactive systems can react to changes and stay responsive under varying workload.
    Message-driven – Reactive systems need to establish a boundary between components by relying on asynchronous message passing.

Q29. What Is Spring WebFlux?

Spring WebFlux is Spring's reactive-stack web framework, and it's an alternative to Spring MVC.

In order to achieve this reactive model and be highly scalable, the entire stack is non-blocking. Check out our tutorial on Spring 5 WebFlux for additional details.
Q30. What Are the Mono and Flux Types?

The WebFlux framework in Spring Framework 5 uses Reactor as its async foundation.

This project provides two core types: Mono to represent a single async value and Flux to represent a stream of async values. They both also implement the Publisher interface defined in the Reactive Streams specification.

Mono implements Publisher and returns 0 or 1 elements:

public abstract class Mono<T> implements Publisher<T> {...}

And Flux implements Publisher and returns N elements:

public abstract class Flux<T> implements Publisher<T> {...}

By definition, the two types represent streams, and so they're both lazy. This means nothing is executed until we consume the stream using the subscribe() method. Both types are also immutable, so calling any method will return a new instance of Flux or Mono.
Q31. What Is the Use of WebClient and WebTestClient?

WebClient is a component in the new Web Reactive framework that can act as a reactive client for performing non-blocking HTTP requests. Since it's reactive client, it can handle reactive streams with back pressure, and it can take full advantage of Java 8 lambdas. It can also handle both sync and async scenarios.

On the other hand, the WebTestClient is a similar class that we can use in tests. Basically, it's a thin shell around the WebClient. It can connect to any server over an HTTP connection. It can also bind directly to WebFlux applications using mock request and response objects, without the need for an HTTP server.
Q32. What Are the Disadvantages of Using Reactive Streams?

There are some major disadvantages to using reactive streams:

    Troubleshooting a Reactive application is a bit difficult, so be sure to check out our tutorial on debugging reactive streams for some handy debugging tips.
    There is limited support for reactive data stores since traditional relational data stores have yet to embrace the reactive paradigm.
    There's an extra learning curve when implementing.

Q33. Is Spring 5 Compatible With Older Versions of Java?

In order to take advantage of Java 8 features, the Spring codebase has been revamped. This means older versions of Java cannot be used. So, the framework requires a minimum of Java 8.
Q34. How Does Spring 5 Integrate With JDK 9 Modularity?

In Spring 5, everything has been modularized. This way, we won't be forced to import jars that may not have the functionalities we're looking for.

Please have a look at our guide to Java 9 modularity for an in-depth understanding of how this technology works.

Let's see an example to understand the new module functionality in Java 9 and how to organize a Spring 5 project based on this concept.

We'll first create a new class that contains a single method to return a String “HelloWorld”. We'll place this within a new Java project — HelloWorldModule:

package com.hello;
public class HelloWorld {
    public String sayHello(){
        return "HelloWorld";
    }
}

Then we create a new module:

module com.hello {
    export com.hello;
}

Now let's create a new Java Project, HelloWorldClient, to consume the above module by defining a module:

module com.hello.client {
    requires com.hello;
}

The above module will be available for testing now:

public class HelloWorldClient {
    public static void main(String[] args){
        HelloWorld helloWorld = new HelloWorld();
        log.info(helloWorld.sayHello());
    }
}

Q35. Can We Use Both Web MVC and WebFlux in the Same Application?

As of now, Spring Boot will only allow either Spring MVC or Spring WebFlux, as Spring Boot tries to auto-configure the context depending on the dependencies that exist in its classpath.

Also, Spring MVC cannot run on Netty. Moreover, MVC is a blocking paradigm and WebFlux is a non-blocking style. So, we shouldn't be mixing both together because they serve different purposes.
7. Conclusion

In this extensive article, we’ve explored some of the most important questions for a technical interview all about Spring.

We hope that this article will help in upcoming Spring interviews. Good luck!
« Previous
Java Annotations Interview Questions (+ Answers)
Get started with Spring 5 and Spring Boot 2, through the Learn Spring course:
>> THE COURSE
Learning to build your API
with Spring?
Download the E-book
1 Comment
Oldest
Comments are closed on this article!
opt-in
Building a REST API with Spring 5?
Download the E-book
The Baeldung logo
Courses

    All Courses
    All Bulk Courses
    The Courses Platform

Series

    Java “Back to Basics” Tutorial
    Jackson JSON Tutorial
    HttpClient 4 Tutorial
    REST with Spring Tutorial
    Spring Persistence Tutorial
    Security with Spring
    Spring Reactive Tutorials

About

    About Baeldung
    The Full Archive
    Write for Baeldung
    Editors
    Jobs
    Our Partners
    Advertise on Baeldung

    Terms of Service Privacy Policy Company Info Contact 






